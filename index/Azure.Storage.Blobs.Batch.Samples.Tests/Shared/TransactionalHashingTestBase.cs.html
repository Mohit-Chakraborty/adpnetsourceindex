<!DOCTYPE html>
<html><head><title>TransactionalHashingTestBase.cs</title><link rel="stylesheet" href="../../styles.css"><script src="../../scripts.js"></script></head>
<body class="cB" onload="i(885);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#Azure.Storage.Blobs.Batch.Samples.Tests/Shared/TransactionalHashingTestBase.cs" target="_top">Shared\TransactionalHashingTestBase.cs</a><br/></td><td><a class="blueLink" href="https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/storage/Azure.Storage.Common/tests/Shared/TransactionalHashingTestBase.cs" target="_blank">View on GitHub</a></td></tr>
<tr><td>Project: <a id="projectPath" class="blueLink" href="/#Azure.Storage.Blobs.Batch.Samples.Tests" target="_top">Azure.Storage.Blobs.Batch.Samples.Tests.csproj</a> (Azure.Storage.Blobs.Batch.Samples.Tests)</td><td></td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
<span class="c">// Copyright (c) Microsoft Corporation. All rights reserved.</span>
<span class="c">// Licensed under the MIT License.</span>
 
<span class="c">// TODO #27253</span>
 
<span class="c">//using System;</span>
<span class="c">//using System.Collections.Generic;</span>
<span class="c">//using System.IO;</span>
<span class="c">//using System.Linq;</span>
<span class="c">//using System.Threading.Tasks;</span>
<span class="c">//using Azure.Core;</span>
<span class="c">//using Azure.Core.TestFramework;</span>
<span class="c">//using NUnit.Framework;</span>
 
<span class="c">//namespace Azure.Storage.Test.Shared</span>
<span class="c">//{</span>
<span class="c">//    /// &lt;summary&gt;</span>
<span class="c">//    /// We&#39;re going to make our tests retry a few additional error types that</span>
<span class="c">//    /// may be more wasteful, but are less likely to cause test failures.</span>
<span class="c">//    /// &lt;/summary&gt;</span>
<span class="c">//    public abstract class TransactionalHashingTestBase&lt;TServiceClient, TContainerClient, TResourceClient, TClientOptions, TEnvironment&gt; : StorageTestBase&lt;TEnvironment&gt;</span>
<span class="c">//        where TServiceClient : class</span>
<span class="c">//        where TContainerClient : class</span>
<span class="c">//        where TResourceClient : class</span>
<span class="c">//        where TClientOptions : ClientOptions</span>
<span class="c">//        where TEnvironment : StorageTestEnvironment, new()</span>
<span class="c">//    {</span>
<span class="c">//        private readonly string _generatedResourceNamePrefix;</span>
 
<span class="c">//        public ClientBuilder&lt;TServiceClient, TClientOptions&gt; ClientBuilder { get; protected set; }</span>
 
<span class="c">//        public TransactionalHashingTestBase(</span>
<span class="c">//            bool async,</span>
<span class="c">//            string generatedResourceNamePrefix = default,</span>
<span class="c">//            RecordedTestMode? mode = null)</span>
<span class="c">//            : base(async, mode)</span>
<span class="c">//        {</span>
<span class="c">//            _generatedResourceNamePrefix = generatedResourceNamePrefix ?? &quot;test-resource-&quot;;</span>
<span class="c">//        }</span>
 
<span class="c">//        #region Service-Specific Methods</span>
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Gets a service-specific disposing container for use with tests in this class.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;service&quot;&gt;Optionally specified service client to get container from.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;containerName&quot;&gt;Optional container name specification.&lt;/param&gt;</span>
<span class="c">//        protected abstract Task&lt;IDisposingContainer&lt;TContainerClient&gt;&gt; GetDisposingContainerAsync(</span>
<span class="c">//            TServiceClient service = default,</span>
<span class="c">//            string containerName = default);</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Gets a new service-specific resource client from a given container, e.g. a BlobClient from a</span>
<span class="c">//        /// BlobContainerClient or a DataLakeFileClient from a DataLakeFileSystemClient.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;container&quot;&gt;Container to get resource from.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;resourceLength&quot;&gt;Sets the resource size in bytes, for resources that require this upfront.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;createResource&quot;&gt;Whether to call CreateAsync on the resource, if necessary.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;resourceName&quot;&gt;Optional name for the resource.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;options&quot;&gt;ClientOptions for the resource client.&lt;/param&gt;</span>
<span class="c">//        protected abstract Task&lt;TResourceClient&gt; GetResourceClientAsync(</span>
<span class="c">//            TContainerClient container,</span>
<span class="c">//            int resourceLength = default,</span>
<span class="c">//            bool createResource = default,</span>
<span class="c">//            string resourceName = default,</span>
<span class="c">//            TClientOptions options = default);</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Calls the 1:1 upload method for the given resource client.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;client&quot;&gt;Client to call upload on.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;source&quot;&gt;Data to upload.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;hashingOptions&quot;&gt;Transactional hashing options to use on upload.&lt;/param&gt;</span>
<span class="c">//        protected abstract Task&lt;Response&gt; UploadPartitionAsync(</span>
<span class="c">//            TResourceClient client,</span>
<span class="c">//            Stream source,</span>
<span class="c">//            UploadTransactionalHashingOptions hashingOptions);</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Calls the 1:1 download method for the given resource client.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;client&quot;&gt;Client to call the download on.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;destination&quot;&gt;Where to send downloaded data.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;hashingOptions&quot;&gt;Transactional hashing options to use on download.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;range&quot;&gt;Range parameter for download, necessary for transactional hash request to be accepted by service.&lt;/param&gt;</span>
<span class="c">//        protected abstract Task&lt;Response&gt; DownloadPartitionAsync(</span>
<span class="c">//            TResourceClient client,</span>
<span class="c">//            Stream destination,</span>
<span class="c">//            DownloadTransactionalHashingOptions hashingOptions,</span>
<span class="c">//            HttpRange range = default);</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Calls the parallel upload method for the given resource client.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;client&quot;&gt;Client to call upload on.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;source&quot;&gt;Data to upload.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;hashingOptions&quot;&gt;Transactional hashing options to use on upload.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;transferOptions&quot;&gt;Storage transfer options to use on upload.&lt;/param&gt;</span>
<span class="c">//        protected abstract Task ParallelUploadAsync(</span>
<span class="c">//            TResourceClient client,</span>
<span class="c">//            Stream source,</span>
<span class="c">//            UploadTransactionalHashingOptions hashingOptions,</span>
<span class="c">//            StorageTransferOptions transferOptions);</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Calls the parallel download method for the given resource client.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;client&quot;&gt;Client to call download on.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;destination&quot;&gt;Where to send downloaded data.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;hashingOptions&quot;&gt;Transactional hashing options to use on download.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;transferOptions&quot;&gt;Storage transfer options to use on download.&lt;/param&gt;</span>
<span class="c">//        protected abstract Task ParallelDownloadAsync(</span>
<span class="c">//            TResourceClient client,</span>
<span class="c">//            Stream destination,</span>
<span class="c">//            DownloadTransactionalHashingOptions hashingOptions,</span>
<span class="c">//            StorageTransferOptions transferOptions);</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Calls the open write method for the given resource client.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;client&quot;&gt;Client to call open write on.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;hashingOptions&quot;&gt;Transactinal hashing options to use in the write stream.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;internalBufferSize&quot;&gt;Buffer size for the write stream.&lt;/param&gt;</span>
<span class="c">//        protected abstract Task&lt;Stream&gt; OpenWriteAsync(</span>
<span class="c">//            TResourceClient client,</span>
<span class="c">//            UploadTransactionalHashingOptions hashingOptions,</span>
<span class="c">//            int internalBufferSize);</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Calls the open read method for the given resource client.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;client&quot;&gt;Client to call open read on.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;hashingOptions&quot;&gt;Transactinal hashing options to use in the read stream.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;internalBufferSize&quot;&gt;Buffer size for the read stream.&lt;/param&gt;</span>
<span class="c">//        protected abstract Task&lt;Stream&gt; OpenReadAsync(</span>
<span class="c">//            TResourceClient client,</span>
<span class="c">//            DownloadTransactionalHashingOptions hashingOptions,</span>
<span class="c">//            int internalBufferSize);</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Sets up data for a test.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;client&quot;&gt;&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt;</span>
<span class="c">//        /// &lt;remarks&gt;</span>
<span class="c">//        /// Not every client has every upload implemented and we dont&#39; directly expose commit for these tests.</span>
<span class="c">//        /// We need a guaranteed way to setup data for download-based tests. This is a space for clients to</span>
<span class="c">//        /// select how they prepare data in a container for a download test.</span>
<span class="c">//        /// &lt;/remarks&gt;</span>
<span class="c">//        protected abstract Task SetupDataAsync(TResourceClient client, Stream data);</span>
<span class="c">//        #endregion</span>
 
<span class="c">//        #region Service-Specific Predicates</span>
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Service-specific check on the given request to determine if this is a request to perform</span>
<span class="c">//        /// a hash assertion on in a parallel upload.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;remarks&gt;</span>
<span class="c">//        /// Not every request sent in a parallel upload has a hash on it. To correctly test whether hashes</span>
<span class="c">//        /// are going out on requests as expected, we need to determine which requests are expected to have</span>
<span class="c">//        /// hashes on them in the first place. E.g. BlobClient sends out PutBlock calls which DO have a hash</span>
<span class="c">//        /// and a PutBlockList call which does NOT have a hash on it.</span>
<span class="c">//        /// &lt;/remarks&gt;</span>
<span class="c">//        protected abstract bool ParallelUploadIsHashExpected(Request request);</span>
<span class="c">//        #endregion</span>
 
<span class="c">//        protected string GetNewResourceName()</span>
<span class="c">//            =&gt; _generatedResourceNamePrefix + ClientBuilder.Recording.Random.NewGuid();</span>
 
<span class="c">//        #region Assertions</span>
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Gets an assertion as to whether a transactional hash appeared on an outgoing request.</span>
<span class="c">//        /// Meant to be injected into a pipeline.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;algorithm&quot;&gt;</span>
<span class="c">//        /// Hash algorithm to look for.</span>
<span class="c">//        /// &lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;isHashExpected&quot;&gt;</span>
<span class="c">//        /// Predicate to determine wheter a hash is expected on that particular request. E.g. on a block blob</span>
<span class="c">//        /// partitioned upload, stage block requests are expected to have a hash but commit block list is not.</span>
<span class="c">//        /// Defaults to all requests expected to have the hash.</span>
<span class="c">//        /// &lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;expectedHash&quot;&gt;</span>
<span class="c">//        /// The actual hash value expected to be on the request, if known. Defaults to no specific value expected or checked.</span>
<span class="c">//        /// &lt;/param&gt;</span>
<span class="c">//        /// &lt;returns&gt;An assertion to put into a pipeline policy.&lt;/returns&gt;</span>
<span class="c">//        internal static Action&lt;Request&gt; GetRequestHashAssertion(TransactionalHashAlgorithm algorithm, Func&lt;Request, bool&gt; isHashExpected = default, byte[] expectedHash = default)</span>
<span class="c">//        {</span>
<span class="c">//            // action to assert a request header is as expected</span>
<span class="c">//            void AssertHash(RequestHeaders headers, string headerName)</span>
<span class="c">//            {</span>
<span class="c">//                if (headers.TryGetValue(headerName, out string hash))</span>
<span class="c">//                {</span>
<span class="c">//                    if (expectedHash != default)</span>
<span class="c">//                    {</span>
<span class="c">//                        Assert.AreEqual(Convert.ToBase64String(expectedHash), hash);</span>
<span class="c">//                    }</span>
<span class="c">//                }</span>
<span class="c">//                else</span>
<span class="c">//                {</span>
<span class="c">//                    Assert.Fail($&quot;{headerName} expected on request but was not found.&quot;);</span>
<span class="c">//                }</span>
<span class="c">//            };</span>
 
<span class="c">//            return request =&gt;</span>
<span class="c">//            {</span>
<span class="c">//                // filter some requests out with predicate</span>
<span class="c">//                if (isHashExpected != default &amp;&amp; !isHashExpected(request))</span>
<span class="c">//                {</span>
<span class="c">//                    return;</span>
<span class="c">//                }</span>
 
<span class="c">//                switch (algorithm)</span>
<span class="c">//                {</span>
<span class="c">//                    case TransactionalHashAlgorithm.MD5:</span>
<span class="c">//                        AssertHash(request.Headers, &quot;Content-MD5&quot;);</span>
<span class="c">//                        break;</span>
<span class="c">//                    case TransactionalHashAlgorithm.StorageCrc64:</span>
<span class="c">//                        AssertHash(request.Headers, &quot;x-ms-content-crc64&quot;);</span>
<span class="c">//                        break;</span>
<span class="c">//                    default:</span>
<span class="c">//                        throw new Exception(&quot;Bad TransactionalHashAlgorithm provided to Request hash assertion.&quot;);</span>
<span class="c">//                }</span>
<span class="c">//            };</span>
<span class="c">//        }</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Gets an assertion as to whether a transactional hash appeared on a returned response.</span>
<span class="c">//        /// Meant to be injected into a pipeline.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;algorithm&quot;&gt;</span>
<span class="c">//        /// Hash algorithm to look for.</span>
<span class="c">//        /// &lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;isHashExpected&quot;&gt;</span>
<span class="c">//        /// Predicate to determine wheter a hash is expected on that particular response. E.g. on OpenRead,</span>
<span class="c">//        /// the initial GetProperties is not expected to have a hash, but download responses are.</span>
<span class="c">//        /// Defaults to all requests expected to have the hash.</span>
<span class="c">//        /// &lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;expectedHash&quot;&gt;</span>
<span class="c">//        /// The actual hash value expected to be on the response, if known. Defaults to no specific value expected or checked.</span>
<span class="c">//        /// &lt;/param&gt;</span>
<span class="c">//        /// &lt;returns&gt;An assertion to put into a pipeline policy.&lt;/returns&gt;</span>
<span class="c">//        internal static Action&lt;Response&gt; GetResponseHashAssertion(TransactionalHashAlgorithm algorithm, Func&lt;Response, bool&gt; isHashExpected = default, byte[] expectedHash = default)</span>
<span class="c">//        {</span>
<span class="c">//            // action to assert a response header is as expected</span>
<span class="c">//            void AssertHash(ResponseHeaders headers, string headerName)</span>
<span class="c">//            {</span>
<span class="c">//                if (headers.TryGetValue(headerName, out string hash))</span>
<span class="c">//                {</span>
<span class="c">//                    if (expectedHash != default)</span>
<span class="c">//                    {</span>
<span class="c">//                        Assert.AreEqual(Convert.ToBase64String(expectedHash), hash);</span>
<span class="c">//                    }</span>
<span class="c">//                }</span>
<span class="c">//                else</span>
<span class="c">//                {</span>
<span class="c">//                    Assert.Fail($&quot;{headerName} expected on response but was not found.&quot;);</span>
<span class="c">//                }</span>
<span class="c">//            };</span>
 
<span class="c">//            return response =&gt;</span>
<span class="c">//            {</span>
<span class="c">//                // filter some requests out with predicate</span>
<span class="c">//                if (isHashExpected != default &amp;&amp; !isHashExpected(response))</span>
<span class="c">//                {</span>
<span class="c">//                    return;</span>
<span class="c">//                }</span>
 
<span class="c">//                switch (algorithm)</span>
<span class="c">//                {</span>
<span class="c">//                    case TransactionalHashAlgorithm.MD5:</span>
<span class="c">//                        AssertHash(response.Headers, &quot;Content-MD5&quot;);</span>
<span class="c">//                        break;</span>
<span class="c">//                    case TransactionalHashAlgorithm.StorageCrc64:</span>
<span class="c">//                        AssertHash(response.Headers, &quot;x-ms-content-crc64&quot;);</span>
<span class="c">//                        break;</span>
<span class="c">//                    default:</span>
<span class="c">//                        throw new Exception(&quot;Bad TransactionalHashAlgorithm provided to Response hash assertion.&quot;);</span>
<span class="c">//                }</span>
<span class="c">//            };</span>
<span class="c">//        }</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Asserts the service returned an error that expected hash did not match hash on upload.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;param name=&quot;writeAction&quot;&gt;Async action to upload data to service.&lt;/param&gt;</span>
<span class="c">//        /// &lt;param name=&quot;algorithm&quot;&gt;Hash algorithm used.&lt;/param&gt;</span>
<span class="c">//        internal static void AssertWriteHashMismatch(AsyncTestDelegate writeAction, TransactionalHashAlgorithm algorithm)</span>
<span class="c">//        {</span>
<span class="c">//            var exception = ThrowsOrInconclusiveAsync&lt;RequestFailedException&gt;(writeAction);</span>
<span class="c">//            switch (algorithm)</span>
<span class="c">//            {</span>
<span class="c">//                case TransactionalHashAlgorithm.MD5:</span>
<span class="c">//                    Assert.AreEqual(&quot;Md5Mismatch&quot;, exception.ErrorCode);</span>
<span class="c">//                    break;</span>
<span class="c">//                case TransactionalHashAlgorithm.StorageCrc64:</span>
<span class="c">//                    Assert.AreEqual(&quot;Crc64Mismatch&quot;, exception.ErrorCode);</span>
<span class="c">//                    break;</span>
<span class="c">//                default:</span>
<span class="c">//                    throw new ArgumentException(&quot;Test arguments contain bad algorithm specifier.&quot;);</span>
<span class="c">//            }</span>
<span class="c">//        }</span>
<span class="c">//        #endregion</span>
 
<span class="c">//        #region UploadPartition Tests</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.MD5)]</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.StorageCrc64)]</span>
<span class="c">//        public virtual async Task UploadPartitionSuccessfulHashComputation(TransactionalHashAlgorithm algorithm)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const int dataLength = Constants.KB;</span>
<span class="c">//            var data = GetRandomBuffer(dataLength);</span>
<span class="c">//            var hashingOptions = new UploadTransactionalHashingOptions</span>
<span class="c">//            {</span>
<span class="c">//                Algorithm = algorithm</span>
<span class="c">//            };</span>
 
<span class="c">//            // make pipeline assertion for checking hash was present on upload</span>
<span class="c">//            var hashPipelineAssertion = new AssertMessageContentsPolicy(checkRequest: GetRequestHashAssertion(algorithm));</span>
<span class="c">//            var clientOptions = ClientBuilder.GetOptions();</span>
<span class="c">//            clientOptions.AddPolicy(hashPipelineAssertion, HttpPipelinePosition.PerCall);</span>
 
<span class="c">//            var client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                resourceLength: dataLength,</span>
<span class="c">//                createResource: true,</span>
<span class="c">//                options: clientOptions);</span>
 
<span class="c">//            // Act</span>
<span class="c">//            using (var stream = new MemoryStream(data))</span>
<span class="c">//            {</span>
<span class="c">//                hashPipelineAssertion.CheckRequest = true;</span>
<span class="c">//                await UploadPartitionAsync(client, stream, hashingOptions);</span>
<span class="c">//            }</span>
 
<span class="c">//            // Assert</span>
<span class="c">//            // Assertion was in the pipeline and the service returning success means the hash was correct</span>
<span class="c">//        }</span>
 
<span class="c">//        [TestCase(TransactionalHashAlgorithm.MD5)]</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.StorageCrc64)]</span>
<span class="c">//        public virtual async Task UploadPartitionUsePrecalculatedHash(TransactionalHashAlgorithm algorithm)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const int dataLength = Constants.KB;</span>
<span class="c">//            var data = GetRandomBuffer(dataLength);</span>
<span class="c">//            // service throws different error for crc only when hash size in incorrect; we don&#39;t want to test that</span>
<span class="c">//            var hashSizeBytes = algorithm switch</span>
<span class="c">//            {</span>
<span class="c">//                TransactionalHashAlgorithm.MD5 =&gt; 16,</span>
<span class="c">//                TransactionalHashAlgorithm.StorageCrc64 =&gt; 8,</span>
<span class="c">//                _ =&gt; throw new ArgumentException(&quot;Cannot determine hash size for provided algorithm type&quot;)</span>
<span class="c">//            };</span>
<span class="c">//            // hash needs to be wrong so we detect difference from auto-SDK correct calculation</span>
<span class="c">//            var precalculatedHash = GetRandomBuffer(hashSizeBytes);</span>
<span class="c">//            var hashingOptions = new UploadTransactionalHashingOptions</span>
<span class="c">//            {</span>
<span class="c">//                Algorithm = algorithm,</span>
<span class="c">//                PrecalculatedHash = precalculatedHash</span>
<span class="c">//            };</span>
 
<span class="c">//            // make pipeline assertion for checking precalculated hash was present on upload</span>
<span class="c">//            var hashPipelineAssertion = new AssertMessageContentsPolicy(checkRequest: GetRequestHashAssertion(algorithm, expectedHash: precalculatedHash));</span>
<span class="c">//            var clientOptions = ClientBuilder.GetOptions();</span>
<span class="c">//            clientOptions.AddPolicy(hashPipelineAssertion, HttpPipelinePosition.PerCall);</span>
 
<span class="c">//            var client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                resourceLength: dataLength,</span>
<span class="c">//                createResource: true,</span>
<span class="c">//                options: clientOptions);</span>
 
<span class="c">//            hashPipelineAssertion.CheckRequest = true;</span>
<span class="c">//            using (var stream = new MemoryStream(data))</span>
<span class="c">//            {</span>
<span class="c">//                // Act</span>
<span class="c">//                AsyncTestDelegate operation = async () =&gt; await UploadPartitionAsync(client, stream, hashingOptions);</span>
 
<span class="c">//                // Assert</span>
<span class="c">//                AssertWriteHashMismatch(operation, algorithm);</span>
<span class="c">//            }</span>
<span class="c">//        }</span>
 
<span class="c">//        [TestCase(TransactionalHashAlgorithm.MD5)]</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.StorageCrc64)]</span>
<span class="c">//        public virtual async Task UploadPartitionMismatchedHashThrows(TransactionalHashAlgorithm algorithm)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const int dataLength = Constants.KB;</span>
<span class="c">//            var data = GetRandomBuffer(dataLength);</span>
<span class="c">//            var hashingOptions = new UploadTransactionalHashingOptions</span>
<span class="c">//            {</span>
<span class="c">//                Algorithm = algorithm</span>
<span class="c">//            };</span>
 
<span class="c">//            // Tamper with stream contents in the pipeline to simulate silent failure in the transit layer</span>
<span class="c">//            var streamTamperPolicy = new TamperStreamContentsPolicy();</span>
<span class="c">//            var clientOptions = ClientBuilder.GetOptions();</span>
<span class="c">//            clientOptions.AddPolicy(streamTamperPolicy, HttpPipelinePosition.PerCall);</span>
 
<span class="c">//            var client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                resourceLength: dataLength,</span>
<span class="c">//                createResource: true,</span>
<span class="c">//                options: clientOptions);</span>
 
<span class="c">//            using (var stream = new MemoryStream(data))</span>
<span class="c">//            {</span>
<span class="c">//                // Act</span>
<span class="c">//                streamTamperPolicy.TransformRequestBody = true;</span>
<span class="c">//                AsyncTestDelegate operation = async () =&gt; await UploadPartitionAsync(client, stream, hashingOptions);</span>
 
<span class="c">//                // Assert</span>
<span class="c">//                AssertWriteHashMismatch(operation, algorithm);</span>
<span class="c">//            }</span>
<span class="c">//        }</span>
<span class="c">//        #endregion</span>
 
<span class="c">//        #region OpenWrite Tests</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.MD5)]</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.StorageCrc64)]</span>
<span class="c">//        public virtual async Task OpenWriteSuccessfulHashComputation(TransactionalHashAlgorithm algorithm)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const int streamBufferSize = Constants.KB; // this one needs to be 512 multiple for page blobs</span>
<span class="c">//            const int dataSize = Constants.KB - 11; // odd number to get some variance</span>
<span class="c">//            const int streamWrites = 10;</span>
 
<span class="c">//            var data = GetRandomBuffer(dataSize);</span>
<span class="c">//            var hashingOptions = new UploadTransactionalHashingOptions</span>
<span class="c">//            {</span>
<span class="c">//                Algorithm = algorithm</span>
<span class="c">//            };</span>
 
<span class="c">//            // make pipeline assertion for checking hash was present on upload</span>
<span class="c">//            var hashPipelineAssertion = new AssertMessageContentsPolicy(checkRequest: GetRequestHashAssertion(algorithm));</span>
<span class="c">//            var clientOptions = ClientBuilder.GetOptions();</span>
<span class="c">//            clientOptions.AddPolicy(hashPipelineAssertion, HttpPipelinePosition.PerCall);</span>
 
<span class="c">//            var client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                // should use dataSize instead of streamBufferSize but this gives 512 multiple and ends up irrelevant for this test</span>
<span class="c">//                resourceLength: streamBufferSize * streamWrites,</span>
<span class="c">//                createResource: true,</span>
<span class="c">//                options: clientOptions);</span>
 
<span class="c">//            // Act</span>
<span class="c">//            var writeStream = await OpenWriteAsync(client, hashingOptions, streamBufferSize);</span>
 
<span class="c">//            // Assert</span>
<span class="c">//            hashPipelineAssertion.CheckRequest = true;</span>
<span class="c">//            foreach (var _ in Enumerable.Range(0, streamWrites))</span>
<span class="c">//            {</span>
<span class="c">//                // triggers pipeline assertion</span>
<span class="c">//                await writeStream.WriteAsync(data, 0, data.Length);</span>
<span class="c">//            }</span>
<span class="c">//        }</span>
 
<span class="c">//        [TestCase(TransactionalHashAlgorithm.MD5)]</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.StorageCrc64)]</span>
<span class="c">//        public virtual async Task OpenWriteMismatchedHashThrows(TransactionalHashAlgorithm algorithm)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const int streamBufferSize = Constants.KB; // this one needs to be 512 multiple for page blobs</span>
<span class="c">//            const int dataSize = Constants.KB - 11; // odd number to get some variance</span>
<span class="c">//            const int streamWrites = 10;</span>
 
<span class="c">//            var data = GetRandomBuffer(dataSize);</span>
<span class="c">//            var hashingOptions = new UploadTransactionalHashingOptions</span>
<span class="c">//            {</span>
<span class="c">//                Algorithm = algorithm</span>
<span class="c">//            };</span>
 
<span class="c">//            // Tamper with stream contents in the pipeline to simulate silent failure in the transit layer</span>
<span class="c">//            var clientOptions = ClientBuilder.GetOptions();</span>
<span class="c">//            var tamperPolicy = new TamperStreamContentsPolicy();</span>
<span class="c">//            clientOptions.AddPolicy(tamperPolicy, HttpPipelinePosition.PerCall);</span>
 
<span class="c">//            var client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                // should use dataSize instead of streamBufferSize but this gives 512 multiple and ends up irrelevant for this test</span>
<span class="c">//                resourceLength: streamBufferSize * streamWrites,</span>
<span class="c">//                createResource: true,</span>
<span class="c">//                options: clientOptions);</span>
 
<span class="c">//            // Act</span>
<span class="c">//            var writeStream = await OpenWriteAsync(client, hashingOptions, streamBufferSize);</span>
 
<span class="c">//            // Assert</span>
<span class="c">//            AssertWriteHashMismatch(async () =&gt;</span>
<span class="c">//            {</span>
<span class="c">//                tamperPolicy.TransformRequestBody = true;</span>
<span class="c">//                foreach (var _ in Enumerable.Range(0, streamWrites))</span>
<span class="c">//                {</span>
<span class="c">//                    await writeStream.WriteAsync(data, 0, data.Length);</span>
<span class="c">//                }</span>
<span class="c">//            }, algorithm);</span>
<span class="c">//        }</span>
<span class="c">//        #endregion</span>
 
<span class="c">//        #region Parallel Upload Tests</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.MD5)]</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.StorageCrc64)]</span>
<span class="c">//        public virtual async Task ParallelUploadSplitSuccessfulHashComputation(TransactionalHashAlgorithm algorithm)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const int dataLength = Constants.KB;</span>
<span class="c">//            var data = GetRandomBuffer(dataLength);</span>
<span class="c">//            var hashingOptions = new UploadTransactionalHashingOptions</span>
<span class="c">//            {</span>
<span class="c">//                Algorithm = algorithm</span>
<span class="c">//            };</span>
<span class="c">//            // force split</span>
<span class="c">//            StorageTransferOptions transferOptions = new StorageTransferOptions</span>
<span class="c">//            {</span>
<span class="c">//                InitialTransferSize = 512,</span>
<span class="c">//                MaximumTransferSize = 512</span>
<span class="c">//            };</span>
 
<span class="c">//            // make pipeline assertion for checking hash was present on upload</span>
<span class="c">//            var hashPipelineAssertion = new AssertMessageContentsPolicy(</span>
<span class="c">//                checkRequest: GetRequestHashAssertion(algorithm, isHashExpected: ParallelUploadIsHashExpected));</span>
<span class="c">//            var clientOptions = ClientBuilder.GetOptions();</span>
<span class="c">//            clientOptions.AddPolicy(hashPipelineAssertion, HttpPipelinePosition.PerCall);</span>
 
<span class="c">//            var client = await GetResourceClientAsync(disposingContainer.Container, resourceLength: dataLength, createResource: true, options: clientOptions);</span>
 
<span class="c">//            // Act</span>
<span class="c">//            using (var stream = new MemoryStream(data))</span>
<span class="c">//            {</span>
<span class="c">//                hashPipelineAssertion.CheckRequest = true;</span>
<span class="c">//                await ParallelUploadAsync(client, stream, hashingOptions, transferOptions);</span>
<span class="c">//            }</span>
 
<span class="c">//            // Assert</span>
<span class="c">//            // Assertion was in the pipeline and the service returning success means the hash was correct</span>
<span class="c">//        }</span>
 
<span class="c">//        [TestCase(TransactionalHashAlgorithm.MD5)]</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.StorageCrc64)]</span>
<span class="c">//        public virtual async Task ParallelUploadOneShotSuccessfulHashComputation(TransactionalHashAlgorithm algorithm)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const int dataLength = Constants.KB;</span>
<span class="c">//            var data = GetRandomBuffer(dataLength);</span>
<span class="c">//            var hashingOptions = new UploadTransactionalHashingOptions</span>
<span class="c">//            {</span>
<span class="c">//                Algorithm = algorithm</span>
<span class="c">//            };</span>
<span class="c">//            // force oneshot</span>
<span class="c">//            StorageTransferOptions transferOptions = new StorageTransferOptions</span>
<span class="c">//            {</span>
<span class="c">//                InitialTransferSize = Constants.MB,</span>
<span class="c">//                MaximumTransferSize = Constants.MB</span>
<span class="c">//            };</span>
 
<span class="c">//            // make pipeline assertion for checking hash was present on upload</span>
<span class="c">//            var hashPipelineAssertion = new AssertMessageContentsPolicy(</span>
<span class="c">//                checkRequest: GetRequestHashAssertion(algorithm, isHashExpected: ParallelUploadIsHashExpected));</span>
<span class="c">//            var clientOptions = ClientBuilder.GetOptions();</span>
<span class="c">//            clientOptions.AddPolicy(hashPipelineAssertion, HttpPipelinePosition.PerCall);</span>
 
<span class="c">//            var client = await GetResourceClientAsync(disposingContainer.Container, resourceLength: dataLength, createResource: true, options: clientOptions);</span>
 
<span class="c">//            // Act</span>
<span class="c">//            using (var stream = new MemoryStream(data))</span>
<span class="c">//            {</span>
<span class="c">//                hashPipelineAssertion.CheckRequest = true;</span>
<span class="c">//                await ParallelUploadAsync(client, stream, hashingOptions, transferOptions);</span>
<span class="c">//            }</span>
 
<span class="c">//            // Assert</span>
<span class="c">//            // Assertion was in the pipeline and the service returning success means the hash was correct</span>
<span class="c">//        }</span>
 
<span class="c">//        [TestCase(TransactionalHashAlgorithm.MD5)]</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.StorageCrc64)]</span>
<span class="c">//        public virtual async Task PrecalculatedHashNotAccepted(TransactionalHashAlgorithm algorithm)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const int dataLength = Constants.KB;</span>
<span class="c">//            var data = GetRandomBuffer(dataLength);</span>
<span class="c">//            var hashingOptions = new UploadTransactionalHashingOptions</span>
<span class="c">//            {</span>
<span class="c">//                Algorithm = algorithm,</span>
<span class="c">//                PrecalculatedHash = GetRandomBuffer(16)</span>
<span class="c">//            };</span>
 
<span class="c">//            var client = await GetResourceClientAsync(disposingContainer.Container, dataLength);</span>
 
<span class="c">//            // Act</span>
<span class="c">//            var exception = ThrowsOrInconclusiveAsync&lt;ArgumentException&gt;(</span>
<span class="c">//                async () =&gt; await ParallelUploadAsync(client, new MemoryStream(data), hashingOptions, transferOptions: default));</span>
 
<span class="c">//            // Assert</span>
<span class="c">//            Assert.AreEqual(&quot;Precalculated hash not supported when potentially partitioning an upload.&quot;, exception.Message);</span>
<span class="c">//        }</span>
<span class="c">//        #endregion</span>
 
<span class="c">//        #region Parallel Download Tests</span>
<span class="c">//        [Test, Combinatorial]</span>
<span class="c">//        public virtual async Task ParallelDownloadSuccessfulHashVerification(</span>
<span class="c">//            [Values(TransactionalHashAlgorithm.MD5, TransactionalHashAlgorithm.StorageCrc64)] TransactionalHashAlgorithm algorithm,</span>
<span class="c">//            [Values(512, 2 * Constants.KB)] int chunkSize)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const int dataLength = 2 * Constants.KB;</span>
<span class="c">//            var data = GetRandomBuffer(dataLength);</span>
 
<span class="c">//            var resourceName = GetNewResourceName();</span>
<span class="c">//            var client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                resourceLength: dataLength,</span>
<span class="c">//                createResource: true,</span>
<span class="c">//                resourceName: resourceName);</span>
<span class="c">//            await SetupDataAsync(client, new MemoryStream(data));</span>
 
<span class="c">//            // make pipeline assertion for checking hash was present on download</span>
<span class="c">//            var hashPipelineAssertion = new AssertMessageContentsPolicy(checkResponse: GetResponseHashAssertion(algorithm));</span>
<span class="c">//            var clientOptions = ClientBuilder.GetOptions();</span>
<span class="c">//            clientOptions.AddPolicy(hashPipelineAssertion, HttpPipelinePosition.PerCall);</span>
 
<span class="c">//            client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                createResource: false,</span>
<span class="c">//                resourceName: resourceName,</span>
<span class="c">//                options: clientOptions);</span>
<span class="c">//            var hashingOptions = new DownloadTransactionalHashingOptions { Algorithm = algorithm };</span>
<span class="c">//            StorageTransferOptions transferOptions = new StorageTransferOptions</span>
<span class="c">//            {</span>
<span class="c">//                InitialTransferSize = chunkSize,</span>
<span class="c">//                MaximumTransferSize = chunkSize</span>
<span class="c">//            };</span>
 
<span class="c">//            // Act</span>
<span class="c">//            hashPipelineAssertion.CheckResponse = true;</span>
<span class="c">//            await ParallelDownloadAsync(client, Stream.Null, hashingOptions, transferOptions);</span>
 
<span class="c">//            // Assert</span>
<span class="c">//            // Assertion was in the pipeline and the SDK not throwing means the hash was validated</span>
<span class="c">//        }</span>
<span class="c">//        #endregion</span>
 
<span class="c">//        #region OpenRead Tests</span>
<span class="c">//        [Test, Combinatorial]</span>
<span class="c">//        public virtual async Task OpenReadSuccessfulHashVerification(</span>
<span class="c">//            [Values(TransactionalHashAlgorithm.MD5, TransactionalHashAlgorithm.StorageCrc64)] TransactionalHashAlgorithm algorithm,</span>
<span class="c">//            [Values(</span>
<span class="c">//                // multiple reads that neatly align</span>
<span class="c">//                Constants.KB,</span>
<span class="c">//                // multiple reads with final having leftover buffer space</span>
<span class="c">//                2 * Constants.KB,</span>
<span class="c">//                // buffer larger than data</span>
<span class="c">//                4 * Constants.KB)] int bufferSize)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            // bufferSize/datasize MUST be a multiple of 512 for pageblob tests</span>
<span class="c">//            const int dataLength = 3 * Constants.KB;</span>
<span class="c">//            var data = GetRandomBuffer(dataLength);</span>
 
<span class="c">//            var resourceName = GetNewResourceName();</span>
<span class="c">//            var client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                resourceLength: dataLength,</span>
<span class="c">//                createResource: true,</span>
<span class="c">//                resourceName: resourceName);</span>
<span class="c">//            await SetupDataAsync(client, new MemoryStream(data));</span>
 
<span class="c">//            // make pipeline assertion for checking hash was present on download</span>
<span class="c">//            var hashPipelineAssertion = new AssertMessageContentsPolicy(checkResponse: GetResponseHashAssertion(algorithm));</span>
<span class="c">//            var clientOptions = ClientBuilder.GetOptions();</span>
<span class="c">//            clientOptions.AddPolicy(hashPipelineAssertion, HttpPipelinePosition.PerCall);</span>
 
<span class="c">//            client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                createResource: false,</span>
<span class="c">//                resourceName: resourceName,</span>
<span class="c">//                options: clientOptions);</span>
<span class="c">//            var hashingOptions = new DownloadTransactionalHashingOptions { Algorithm = algorithm };</span>
 
<span class="c">//            // Act</span>
<span class="c">//            var readStream = await OpenReadAsync(client, hashingOptions, bufferSize);</span>
 
<span class="c">//            // Assert</span>
<span class="c">//            hashPipelineAssertion.CheckResponse = true;</span>
<span class="c">//            await DoesNotThrowOrInconclusiveAsync(async () =&gt; await readStream.CopyToAsync(Stream.Null));</span>
<span class="c">//        }</span>
<span class="c">//        #endregion</span>
 
<span class="c">//        #region Download Streaming/Content Tests</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.MD5)]</span>
<span class="c">//        [TestCase(TransactionalHashAlgorithm.StorageCrc64)]</span>
<span class="c">//        public virtual async Task DownloadSuccessfulHashVerification(TransactionalHashAlgorithm algorithm)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const int dataLength = Constants.KB;</span>
<span class="c">//            var data = GetRandomBuffer(dataLength);</span>
 
<span class="c">//            var resourceName = GetNewResourceName();</span>
<span class="c">//            var client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                resourceLength: dataLength,</span>
<span class="c">//                createResource: true,</span>
<span class="c">//                resourceName: resourceName);</span>
<span class="c">//            await SetupDataAsync(client, new MemoryStream(data));</span>
 
<span class="c">//            var hashingOptions = new DownloadTransactionalHashingOptions { Algorithm = algorithm };</span>
 
<span class="c">//            // Act</span>
<span class="c">//            var response = await DownloadPartitionAsync(client, Stream.Null, hashingOptions, new HttpRange(length: data.Length));</span>
 
<span class="c">//            // Assert</span>
<span class="c">//            // no policies this time; just check response headers</span>
<span class="c">//            switch (algorithm)</span>
<span class="c">//            {</span>
<span class="c">//                case TransactionalHashAlgorithm.MD5:</span>
<span class="c">//                    Assert.True(response.Headers.Contains(&quot;Content-MD5&quot;));</span>
<span class="c">//                    break;</span>
<span class="c">//                case TransactionalHashAlgorithm.StorageCrc64:</span>
<span class="c">//                    Assert.True(response.Headers.Contains(&quot;x-ms-content-crc64&quot;));</span>
<span class="c">//                    break;</span>
<span class="c">//                default:</span>
<span class="c">//                    Assert.Fail(&quot;Test can&#39;t validate given algorithm type.&quot;);</span>
<span class="c">//                    break;</span>
<span class="c">//            }</span>
<span class="c">//        }</span>
 
<span class="c">//        [Test, Combinatorial]</span>
<span class="c">//        public virtual async Task DownloadHashMismatchThrows(</span>
<span class="c">//            [Values(TransactionalHashAlgorithm.MD5, TransactionalHashAlgorithm.StorageCrc64)] TransactionalHashAlgorithm algorithm,</span>
<span class="c">//            [Values(true, false)] bool validate)</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const int dataLength = Constants.KB;</span>
<span class="c">//            var data = GetRandomBuffer(dataLength);</span>
 
<span class="c">//            var resourceName = GetNewResourceName();</span>
<span class="c">//            var client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                resourceLength: dataLength,</span>
<span class="c">//                createResource: true,</span>
<span class="c">//                resourceName: resourceName);</span>
<span class="c">//            await SetupDataAsync(client, new MemoryStream(data));</span>
 
<span class="c">//            var hashingOptions = new DownloadTransactionalHashingOptions { Algorithm = algorithm, Validate = validate };</span>
 
<span class="c">//            // alter response contents in pipeline, forcing a hash mismatch on verification step</span>
<span class="c">//            var clientOptions = ClientBuilder.GetOptions();</span>
<span class="c">//            clientOptions.AddPolicy(new TamperStreamContentsPolicy() { TransformResponseBody = true }, HttpPipelinePosition.PerCall);</span>
<span class="c">//            client = await GetResourceClientAsync(</span>
<span class="c">//                disposingContainer.Container,</span>
<span class="c">//                createResource: false,</span>
<span class="c">//                resourceName: resourceName,</span>
<span class="c">//                options: clientOptions);</span>
 
<span class="c">//            // Act</span>
<span class="c">//            AsyncTestDelegate operation = async () =&gt; await DownloadPartitionAsync(client, Stream.Null, hashingOptions, new HttpRange(length: data.Length));</span>
 
<span class="c">//            // Assert</span>
<span class="c">//            if (validate)</span>
<span class="c">//            {</span>
<span class="c">//                // SDK responsible for finding bad hash. Throw.</span>
<span class="c">//                ThrowsOrInconclusiveAsync&lt;InvalidDataException&gt;(operation);</span>
<span class="c">//            }</span>
<span class="c">//            else</span>
<span class="c">//            {</span>
<span class="c">//                // bad hash is for caller to find. Don&#39;t throw.</span>
<span class="c">//                await DoesNotThrowOrInconclusiveAsync(operation);</span>
<span class="c">//            }</span>
<span class="c">//        }</span>
<span class="c">//        #endregion</span>
 
<span class="c">//        [Test]</span>
<span class="c">//        public void TestDefaults()</span>
<span class="c">//        {</span>
<span class="c">//            var uploadOptions = new UploadTransactionalHashingOptions();</span>
<span class="c">//            Assert.AreEqual(TransactionalHashAlgorithm.StorageCrc64, uploadOptions.Algorithm);</span>
<span class="c">//            Assert.IsNull(uploadOptions.PrecalculatedHash);</span>
 
<span class="c">//            var downloadOptions = new DownloadTransactionalHashingOptions();</span>
<span class="c">//            Assert.AreEqual(TransactionalHashAlgorithm.StorageCrc64, downloadOptions.Algorithm);</span>
<span class="c">//            Assert.IsTrue(downloadOptions.Validate);</span>
<span class="c">//        }</span>
 
<span class="c">//        [Test]</span>
<span class="c">//        public async Task RoundtripWIthDefaults()</span>
<span class="c">//        {</span>
<span class="c">//            await using IDisposingContainer&lt;TContainerClient&gt; disposingContainer = await GetDisposingContainerAsync();</span>
 
<span class="c">//            // Arrange</span>
<span class="c">//            const TransactionalHashAlgorithm expectedAlgorithm = TransactionalHashAlgorithm.StorageCrc64;</span>
<span class="c">//            const int dataLength = Constants.KB;</span>
<span class="c">//            var data = GetRandomBuffer(dataLength);</span>
<span class="c">//            var uploadHashingOptions = new UploadTransactionalHashingOptions();</span>
<span class="c">//            var downloadHashingOptions = new DownloadTransactionalHashingOptions();</span>
<span class="c">//            var clientOptions = ClientBuilder.GetOptions();</span>
<span class="c">//            StorageTransferOptions transferOptions = new StorageTransferOptions</span>
<span class="c">//            {</span>
<span class="c">//                InitialTransferSize = 512,</span>
<span class="c">//                MaximumTransferSize = 512</span>
<span class="c">//            };</span>
 
<span class="c">//            // make pipeline assertion for checking hash was present on upload AND download</span>
<span class="c">//            var hashPipelineAssertion = new AssertMessageContentsPolicy(</span>
<span class="c">//                checkRequest: GetRequestHashAssertion(expectedAlgorithm, isHashExpected: ParallelUploadIsHashExpected),</span>
<span class="c">//                checkResponse: GetResponseHashAssertion(expectedAlgorithm));</span>
<span class="c">//            clientOptions.AddPolicy(hashPipelineAssertion, HttpPipelinePosition.PerCall);</span>
 
<span class="c">//            var client = await GetResourceClientAsync(disposingContainer.Container, resourceLength: dataLength, createResource: true, options: clientOptions);</span>
 
<span class="c">//            // Act</span>
<span class="c">//            using (var stream = new MemoryStream(data))</span>
<span class="c">//            {</span>
<span class="c">//                hashPipelineAssertion.CheckRequest = true;</span>
<span class="c">//                await ParallelUploadAsync(client, stream, uploadHashingOptions, transferOptions);</span>
<span class="c">//                hashPipelineAssertion.CheckRequest = false;</span>
<span class="c">//            }</span>
 
<span class="c">//            hashPipelineAssertion.CheckResponse = true;</span>
<span class="c">//            await ParallelDownloadAsync(client, Stream.Null, downloadHashingOptions, transferOptions);</span>
 
<span class="c">//            // Assert</span>
<span class="c">//            // Assertion was in the pipeline and the service returning success means the hash was correct</span>
<span class="c">//        }</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Replicates &lt;c&gt;ThrowsOrInconclusiveAsync&amp;lt;&lt;typeparamref name=&quot;TException&quot;/&gt;&amp;gt;&lt;/c&gt; while allowing</span>
<span class="c">//        /// NUnit &lt;see cref=&quot;ResultStateException&quot;/&gt;s to bubble up to the test framework.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        /// &lt;typeparam name=&quot;TException&quot;&gt;Expected exception type.&lt;/typeparam&gt;</span>
<span class="c">//        private static TException ThrowsOrInconclusiveAsync&lt;TException&gt;(AsyncTestDelegate code)</span>
<span class="c">//            where TException : Exception</span>
<span class="c">//        {</span>
<span class="c">//            var exception = Assert.ThrowsAsync(Is.InstanceOf&lt;TException&gt;().Or.InstanceOf&lt;ResultStateException&gt;(), code);</span>
 
<span class="c">//            // let nunit results bubble up</span>
<span class="c">//            if (exception is ResultStateException)</span>
<span class="c">//            {</span>
<span class="c">//                throw exception;</span>
<span class="c">//            }</span>
 
<span class="c">//            return exception as TException;</span>
<span class="c">//        }</span>
 
<span class="c">//        /// &lt;summary&gt;</span>
<span class="c">//        /// Replicates &lt;c&gt;DoesNotThrowOrInconclusiveAsync&lt;/c&gt; while allowing</span>
<span class="c">//        /// NUnit &lt;see cref=&quot;ResultStateException&quot;/&gt;s to bubble up to the test framework.</span>
<span class="c">//        /// &lt;/summary&gt;</span>
<span class="c">//        private static async Task DoesNotThrowOrInconclusiveAsync(AsyncTestDelegate code)</span>
<span class="c">//        {</span>
<span class="c">//            try</span>
<span class="c">//            {</span>
<span class="c">//                await code.Invoke();</span>
<span class="c">//            }</span>
<span class="c">//            catch (Exception e) when (e is not ResultStateException)</span>
<span class="c">//            {</span>
<span class="c">//                Assert.Fail($&quot;Expected: No Exception to be thrown\nBut was: {e}&quot;);</span>
<span class="c">//            }</span>
<span class="c">//        }</span>
<span class="c">//    }</span>
<span class="c">//}</span>
</pre></td></tr></table></div></body></html>
