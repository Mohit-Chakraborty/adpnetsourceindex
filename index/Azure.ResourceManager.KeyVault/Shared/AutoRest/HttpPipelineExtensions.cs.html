<!DOCTYPE html>
<html><head><title>HttpPipelineExtensions.cs</title><link rel="stylesheet" href="../../../styles.css"><script src="../../../scripts.js"></script></head>
<body class="cB" onload="i(99);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#Azure.ResourceManager.KeyVault/Shared/AutoRest/HttpPipelineExtensions.cs" target="_top">Shared\AutoRest\HttpPipelineExtensions.cs</a><br/></td><td></td></tr>
<tr><td>Project: <a id="projectPath" class="blueLink" href="/#Azure.ResourceManager.KeyVault" target="_top">Azure.ResourceManager.KeyVault.csproj</a> (Azure.ResourceManager.KeyVault)</td><td></td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
<span class="c">// Copyright (c) Microsoft Corporation. All rights reserved.</span>
<span class="c">// Licensed under the MIT License.</span>
 
<span class="k preprocess">#</span><span class="k preprocess">nullable</span> <span class="k preprocess">enable</span>
 
<b>using</b> <span class="i n">System</span>.<span class="i n">Threading</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Threading</span>.<span class="i n">Tasks</span>;
<b>using</b> <span class="i n">Azure</span>.<span class="i n">Core</span>.<span class="i n">Pipeline</span>;
 
<b>namespace</b> <span class="i n">Azure</span>.<span class="i n">Core</span>
{
    <b>internal static class</b> <a id="b59cf260facb8daa" href="../../R/../../0000000000.html" target="n" data-glyph="2,0" class="t t">HttpPipelineExtensions</a>
    {
<span class="k preprocess">#</span><span class="k preprocess">if</span> <span class="i">EXPERIMENTAL</span>
<span class="e">        public static async ValueTask&lt;Response&gt; ProcessMessageAsync(this HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext? requestContext, CancellationToken cancellationToken = default)
        {
            var (userCt, statusOption) = ApplyRequestContext(requestContext);
            if (!userCt.CanBeCanceled || !cancellationToken.CanBeCanceled)
            {
                await pipeline.SendAsync(message, cancellationToken.CanBeCanceled ? cancellationToken : userCt).ConfigureAwait(false);
            }
            else
            {
                using var cts = CancellationTokenSource.CreateLinkedTokenSource(userCt, cancellationToken);
                await pipeline.SendAsync(message, cts.Token).ConfigureAwait(false);
            }
 
            if (statusOption == ErrorOptions.NoThrow || !message.ResponseClassifier.IsErrorResponse(message))
            {
                return message.Response;
            }
 
            throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
        }
 
        public static Response ProcessMessage(this HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext? requestContext, CancellationToken cancellationToken = default)
        {
            var (userCt, statusOption) = ApplyRequestContext(requestContext);
            if (!userCt.CanBeCanceled || !cancellationToken.CanBeCanceled)
            {
                pipeline.Send(message, cancellationToken.CanBeCanceled ? cancellationToken : userCt);
            }
            else
            {
                using var cts = CancellationTokenSource.CreateLinkedTokenSource(userCt, cancellationToken);
                pipeline.Send(message, cts.Token);
            }
 
            if (statusOption == ErrorOptions.NoThrow || !message.ResponseClassifier.IsErrorResponse(message))
            {
                return message.Response;
            }
 
            throw clientDiagnostics.CreateRequestFailedException(message.Response);
        }
 
        public static async ValueTask&lt;Response&lt;bool&gt;&gt; ProcessHeadAsBoolMessageAsync(this HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext? requestContext)
        {
            var response = await pipeline.ProcessMessageAsync(message, clientDiagnostics, requestContext).ConfigureAwait(false);
            switch (response.Status)
            {
                case &gt;= 200 and &lt; 300:
                    return Response.FromValue(true, response);
                case &gt;= 400 and &lt; 500:
                    return Response.FromValue(false, response);
                default:
                    var exception = await clientDiagnostics.CreateRequestFailedExceptionAsync(response).ConfigureAwait(false);
                    return new ErrorResponse&lt;bool&gt;(response, exception);
            }
        }
 
        public static Response&lt;bool&gt; ProcessHeadAsBoolMessage(this HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext? requestContext)
        {
            var response = pipeline.ProcessMessage(message, clientDiagnostics, requestContext);
            switch (response.Status)
            {
                case &gt;= 200 and &lt; 300:
                    return Response.FromValue(true, response);
                case &gt;= 400 and &lt; 500:
                    return Response.FromValue(false, response);
                default:
                    var exception = clientDiagnostics.CreateRequestFailedException(response);
                    return new ErrorResponse&lt;bool&gt;(response, exception);
            }
        }
 
        private static (CancellationToken CancellationToken, ErrorOptions ErrorOptions) ApplyRequestContext(RequestContext? requestContext)
        {
            if (requestContext == null)
            {
                return (CancellationToken.None, ErrorOptions.Default);
            }
 
            return (requestContext.CancellationToken, requestContext.ErrorOptions);
        }
</span><span class="k preprocess">#</span><span class="k preprocess">endif</span>
    }
}
</pre></td></tr></table></div></body></html>
