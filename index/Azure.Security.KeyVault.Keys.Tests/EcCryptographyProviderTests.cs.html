<!DOCTYPE html>
<html><head><title>EcCryptographyProviderTests.cs</title><link rel="stylesheet" href="../styles.css"><script src="../scripts.js"></script></head>
<body class="cB" onload="i(303);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#Azure.Security.KeyVault.Keys.Tests/EcCryptographyProviderTests.cs" target="_top">EcCryptographyProviderTests.cs</a><br/></td><td><a class="blueLink" href="https://github.com/Azure/azure-sdk-for-net/tree/master//sdk/keyvault/Azure.Security.KeyVault.Keys/tests/EcCryptographyProviderTests.cs" target="_blank">View on GitHub</a></td></tr>
<tr><td>Project: <a id="projectPath" class="blueLink" href="/#Azure.Security.KeyVault.Keys.Tests" target="_top">Azure.Security.KeyVault.Keys.Tests.csproj</a> (Azure.Security.KeyVault.Keys.Tests)</td><td></td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
<span class="c">// Copyright (c) Microsoft Corporation. All rights reserved.</span>
<span class="c">// Licensed under the MIT License.</span>
 
<b>using</b> <span class="i n">System</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Collections</span>.<span class="i n">Generic</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Security</span>.<span class="i n">Cryptography</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Threading</span>.<span class="i n">Tasks</span>;
<b>using</b> <span class="i n">Azure</span>.<span class="i n">Security</span>.<span class="i n">KeyVault</span>.<span class="i n">Keys</span>.<span class="i n">Cryptography</span>;
<b>using</b> <span class="i n">NUnit</span>.<span class="i n">Framework</span>;
 
<b>namespace</b> <span class="i n">Azure</span>.<span class="i n">Security</span>.<span class="i n">KeyVault</span>.<span class="i n">Keys</span>.<span class="i n">Tests</span>
{
<span class="k preprocess">#</span><span class="k preprocess">if</span> !<span class="i">NET461</span>
<span class="e">
    public class EcCryptographyProviderTests
    {
        [TestCase(&quot;sign&quot;, true)]
        [TestCase(&quot;verify&quot;, true)]
        [TestCase(&quot;encrypt&quot;, false)]
        [TestCase(&quot;decrypt&quot;, false)]
        [TestCase(&quot;wrapKey&quot;, false)]
        [TestCase(&quot;unwrapKey&quot;, false)]
        public void SupportsOperation(string operationValue, bool supported)
        {
            JsonWebKey jwk = KeyModelFactory.JsonWebKey(KeyType.Ec, curveName: KeyCurveName.P256, keyOps: new[] { KeyOperation.Sign, KeyOperation.Verify });
 
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
            KeyOperation operation = new KeyOperation(operationValue);
 
            Assert.AreEqual(supported, client.SupportsOperation(operation));
        }
 
        [Test]
        public void SupportsOperationUnsupportedCurve()
        {
            JsonWebKey jwk = KeyModelFactory.JsonWebKey(KeyType.Ec, curveName: &quot;invalid&quot;, keyOps: new[] { KeyOperation.Sign, KeyOperation.Verify });
 
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
 
            // The provider caches the original allow key operations to facilitate tracing. Operation will still be sent to the service.
            Assert.IsTrue(client.SupportsOperation(KeyOperation.Sign));
        }
 
        [Test]
        public void SupportsOperationUnauthorizedOperation()
        {
            JsonWebKey jwk = KeyModelFactory.JsonWebKey(KeyType.Ec, curveName: &quot;invalid&quot;, keyOps: new[] { KeyOperation.Verify });
 
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
 
            Assert.IsFalse(client.SupportsOperation(KeyOperation.Sign));
        }
 
        [Test]
        public async Task Sign()
        {
            using ECDsa ecdsa = ECDsa.Create();
            ecdsa.GenerateKey(ECCurve.NamedCurves.nistP256);
 
            JsonWebKey jwk = new JsonWebKey(ecdsa, true) { Id = &quot;test&quot; };
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
            SignatureAlgorithm algorithm = GetSignatureAlgorithm(jwk);
 
            byte[] digest = new byte[] { 0x9f, 0x86, 0xd0, 0x81, 0x88, 0x4c, 0x7d, 0x65, 0x9a, 0x2f, 0xea, 0xa0, 0xc5, 0x5a, 0xd0, 0x15, 0xa3, 0xbf, 0x4f, 0x1b, 0x2b, 0x0b, 0x82, 0x2c, 0xd1, 0x5d, 0x6c, 0x15, 0xb0, 0xf0, 0x0a, 0x08 };
            SignResult result = await client.SignAsync(algorithm, digest, default);
 
            Assert.AreEqual(algorithm, result.Algorithm);
            Assert.AreEqual(&quot;test&quot;, result.KeyId);
            Assert.AreEqual(64, result.Signature.Length);
        }
 
        [Test]
        public void SignThrowsOnNullDigest()
        {
            using ECDsa ecdsa = ECDsa.Create();
 
            JsonWebKey jwk = new JsonWebKey(ecdsa);
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
            SignatureAlgorithm algorithm = GetSignatureAlgorithm(jwk);
 
            Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; client.Sign(algorithm, null, default));
        }
 
        [TestCaseSource(nameof(GetInvalidKeys))]
        public void SignThrowsOnInvalidKey(JsonWebKey jwk, SignatureAlgorithm algorithm)
        {
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
 
            byte[] digest = new byte[1] { 0xff };
            Assert.Throws&lt;ArgumentException&gt;(() =&gt; client.Sign(algorithm, digest, default), &quot;Expected exception with wrong key length&quot;);
        }
 
        [Test]
        public void SignReturnsNullWithoutPrivateKey()
        {
            using ECDsa ecdsa = ECDsa.Create();
            ECParameters ecParameters = ecdsa.ExportParameters(false);
            ecdsa.ImportParameters(ecParameters);
 
            JsonWebKey jwk = new JsonWebKey(ecdsa)
            {
                Id = &quot;test&quot;,
            };
 
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
            SignatureAlgorithm algorithm = GetSignatureAlgorithm(jwk);
 
            Assert.IsNull(client.Sign(algorithm, new byte[] { 0xff }, default));
        }
 
        [Test]
        public void SignReturnsNullOnUnsupported()
        {
            JsonWebKey jwk = KeyModelFactory.JsonWebKey(KeyType.Ec, curveName: &quot;invalid&quot;, keyOps: new[] { KeyOperation.Sign });
 
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
            SignResult result = client.Sign(default, new byte[] { 0xff }, default);
 
            Assert.IsNull(result);
        }
 
        [Test]
        public async Task Verify()
        {
            using ECDsa ecdsa = ECDsa.Create();
            ecdsa.GenerateKey(ECCurve.NamedCurves.nistP256);
 
            JsonWebKey jwk = new JsonWebKey(ecdsa, true) { Id = &quot;test&quot; };
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
            SignatureAlgorithm algorithm = GetSignatureAlgorithm(jwk);
 
            byte[] digest = new byte[] { 0x9f, 0x86, 0xd0, 0x81, 0x88, 0x4c, 0x7d, 0x65, 0x9a, 0x2f, 0xea, 0xa0, 0xc5, 0x5a, 0xd0, 0x15, 0xa3, 0xbf, 0x4f, 0x1b, 0x2b, 0x0b, 0x82, 0x2c, 0xd1, 0x5d, 0x6c, 0x15, 0xb0, 0xf0, 0x0a, 0x08 };
            SignResult signResult = await client.SignAsync(algorithm, digest, default);
            VerifyResult verifyResult = await client.VerifyAsync(algorithm, digest, signResult.Signature, default);
 
            Assert.AreEqual(algorithm, verifyResult.Algorithm);
            Assert.AreEqual(&quot;test&quot;, verifyResult.KeyId);
            Assert.IsTrue(verifyResult.IsValid);
        }
 
        [Test]
        public void VerifyThrowsOnNullDigest()
        {
            using ECDsa ecdsa = ECDsa.Create();
 
            JsonWebKey jwk = new JsonWebKey(ecdsa);
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
            SignatureAlgorithm algorithm = GetSignatureAlgorithm(jwk);
 
            Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; client.Verify(algorithm, null, null, default));
        }
 
        [Test]
        public void VerifyThrowsOnNullSignature()
        {
            using ECDsa ecdsa = ECDsa.Create();
 
            JsonWebKey jwk = new JsonWebKey(ecdsa);
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
            SignatureAlgorithm algorithm = GetSignatureAlgorithm(jwk);
 
            Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; client.Verify(algorithm, new byte[] { 0xff }, null, default));
        }
 
        [TestCaseSource(nameof(GetInvalidKeys))]
        public void VerifyThrowsOnInvalidKey(JsonWebKey jwk, SignatureAlgorithm algorithm)
        {
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
 
            byte[] digest = new byte[] { 0xff };
            byte[] signature = new byte[] { 0xff, 0xff };
            Assert.Throws&lt;ArgumentException&gt;(() =&gt; client.Verify(algorithm, digest, signature, default), &quot;Expected exception with wrong key length&quot;);
        }
 
        [Test]
        public void VerifyReturnsNullOnUnsupported()
        {
            JsonWebKey jwk = KeyModelFactory.JsonWebKey(KeyType.Ec, curveName: &quot;invalid&quot;, keyOps: new[] { KeyOperation.Sign });
 
            EcCryptographyProvider client = new EcCryptographyProvider(jwk, null);
 
            byte[] digest = new byte[] { 0xff };
            byte[] signature = new byte[] { 0xff, 0xff };
            VerifyResult result = client.Verify(default, digest, signature, default);
 
            Assert.IsNull(result);
        }
 
        [Test]
        public void SignBeforeValidDate()
        {
            using ECDsa ecdsa = ECDsa.Create();
 
            KeyVaultKey key = new KeyVaultKey(&quot;test&quot;)
            {
                Key = new JsonWebKey(ecdsa),
                Properties =
                {
                    NotBefore = DateTimeOffset.Now.AddDays(1),
                },
            };
 
            EcCryptographyProvider client = new EcCryptographyProvider(key.Key, key.Properties);
 
            byte[] digest = new byte[] { 0x9f, 0x86, 0xd0, 0x81, 0x88, 0x4c, 0x7d, 0x65, 0x9a, 0x2f, 0xea, 0xa0, 0xc5, 0x5a, 0xd0, 0x15, 0xa3, 0xbf, 0x4f, 0x1b, 0x2b, 0x0b, 0x82, 0x2c, 0xd1, 0x5d, 0x6c, 0x15, 0xb0, 0xf0, 0x0a, 0x08 };
            InvalidOperationException ex = Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; client.Sign(GetSignatureAlgorithm(key.Key), digest, default));
            Assert.AreEqual($&quot;The key \&quot;test\&quot; is not valid before {key.Properties.NotBefore.Value:r}.&quot;, ex.Message);
        }
 
        [Test]
        public void SignAfterValidDate()
        {
            using ECDsa ecdsa = ECDsa.Create();
 
            KeyVaultKey key = new KeyVaultKey(&quot;test&quot;)
            {
                Key = new JsonWebKey(ecdsa),
                Properties =
                {
                    ExpiresOn = DateTimeOffset.Now.AddDays(-1),
                },
            };
 
            EcCryptographyProvider client = new EcCryptographyProvider(key.Key, key.Properties);
 
            byte[] digest = new byte[] { 0x9f, 0x86, 0xd0, 0x81, 0x88, 0x4c, 0x7d, 0x65, 0x9a, 0x2f, 0xea, 0xa0, 0xc5, 0x5a, 0xd0, 0x15, 0xa3, 0xbf, 0x4f, 0x1b, 0x2b, 0x0b, 0x82, 0x2c, 0xd1, 0x5d, 0x6c, 0x15, 0xb0, 0xf0, 0x0a, 0x08 };
            InvalidOperationException ex = Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; client.Sign(GetSignatureAlgorithm(key.Key), digest, default));
            Assert.AreEqual($&quot;The key \&quot;test\&quot; is not valid after {key.Properties.ExpiresOn.Value:r}.&quot;, ex.Message);
        }
 
        private static IEnumerable&lt;TestCaseData&gt; GetInvalidKeys()
        {
            static IEnumerable&lt;(string, SignatureAlgorithm[])&gt; GetInvalidPairs()
            {
                yield return (&quot;1.2.840.10045.3.1.7&quot;, new[] { SignatureAlgorithm.ES256K, SignatureAlgorithm.ES384, SignatureAlgorithm.ES512 }); // P-256
                yield return (&quot;1.3.132.0.10&quot;, new[] { SignatureAlgorithm.ES256, SignatureAlgorithm.ES384, SignatureAlgorithm.ES512 }); // P-256K
                yield return (&quot;1.3.132.0.34&quot;, new[] { SignatureAlgorithm.ES256, SignatureAlgorithm.ES256K, SignatureAlgorithm.ES512 }); // P-384
                yield return (&quot;1.3.132.0.35&quot;, new[] { SignatureAlgorithm.ES256, SignatureAlgorithm.ES256K, SignatureAlgorithm.ES384 }); // P-521
            };
 
            foreach ((string oid, SignatureAlgorithm[] algorithms) in GetInvalidPairs())
            {
                using ECDsa ecdsa = ECDsa.Create();
                ECCurve curve = ECCurve.CreateFromValue(oid);
 
                bool supported = true;
                try
                {
                    ecdsa.GenerateKey(curve);
                }
                catch (NotSupportedException)
                {
                    supported = false;
                }
 
                if (supported)
                {
                    JsonWebKey jwk = new JsonWebKey(ecdsa, true)
                    {
                        Id = &quot;test&quot;,
                    };
 
                    foreach (SignatureAlgorithm algorithm in algorithms)
                    {
                        yield return new TestCaseData(jwk, algorithm);
                    }
                }
                else
                {
                    yield return new TestCaseData(null, default(SignatureAlgorithm)).Ignore($&quot;This platform does not support OID {oid}&quot;);
                }
            }
        }
 
        private static SignatureAlgorithm GetSignatureAlgorithm(JsonWebKey jwk)
        {
            if (jwk.CurveName == KeyCurveName.P256)
            {
                return SignatureAlgorithm.ES256Value;
            }
 
            if (jwk.CurveName == KeyCurveName.P256K)
            {
                return SignatureAlgorithm.ES256KValue;
            }
 
            if (jwk.CurveName == KeyCurveName.P384)
            {
                return SignatureAlgorithm.ES384Value;
            }
 
            if (jwk.CurveName == KeyCurveName.P521)
            {
                return SignatureAlgorithm.ES512Value;
            }
 
            throw new NotSupportedException();
        }
    }
 
</span><span class="k preprocess">#</span><span class="k preprocess">endif</span>
}
</pre></td></tr></table></div></body></html>
