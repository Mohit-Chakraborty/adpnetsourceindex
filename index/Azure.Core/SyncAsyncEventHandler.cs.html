<!DOCTYPE html>
<html><head><title>SyncAsyncEventHandler.cs</title><link rel="stylesheet" href="../styles.css"><script src="../scripts.js"></script></head>
<body class="cB" onload="i(228);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#Azure.Core/SyncAsyncEventHandler.cs" target="_top">SyncAsyncEventHandler.cs</a><br/></td><td></td></tr>
<tr><td>Project: <a id="projectPath" class="blueLink" href="/#Azure.Core" target="_top">Azure.Core.csproj</a> (Azure.Core)</td><td></td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
<span class="c">// Copyright (c) Microsoft Corporation. All rights reserved.</span>
<span class="c">// Licensed under the MIT License.</span>
 
<b>using</b> <span class="i n">System</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Threading</span>.<span class="i n">Tasks</span>;
 
<b>namespace</b> <span class="i n">Azure</span>.<span class="i n">Core</span>
{
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> Represents a method that can handle an event and execute either</span>
    <span class="c">///</span><span class="c"> synchronously or asynchronously.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">typeparam</span> <span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r0 r t">T</span><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> Type of the event arguments deriving or equal to</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="SyncAsyncEventArgs.cs.html#29b26fe52d12ab1a" class="t t">SyncAsyncEventArgs</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c">.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">typeparam</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span> <span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r1 r">e</span><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> An </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="SyncAsyncEventArgs.cs.html#29b26fe52d12ab1a" class="t t">SyncAsyncEventArgs</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> instance that contains the event</span>
    <span class="c">///</span><span class="c"> data.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> A task that represents the handler.  You can return</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@1@netstandard/A.html#045a746eb48cbaa9" class="t t">Task</a>.<a href="@1@netstandard/A.html#66f1c3e3e272f591" class="i property">CompletedTask</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> if implementing a sync handler.</span>
    <span class="c">///</span><span class="c"> Please see the Remarks section for more details.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">example</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> If you&#39;re using the synchronous, blocking methods of a client (i.e.,</span>
    <span class="c">///</span><span class="c"> methods without an Async suffix), they will raise events that require</span>
    <span class="c">///</span><span class="c"> handlers to execute synchronously as well.  Even though the signature</span>
    <span class="c">///</span><span class="c"> of your handler returns a </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@1@netstandard/A.html#045a746eb48cbaa9" class="t t">Task</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c">, you should write regular</span>
    <span class="c">///</span><span class="c"> sync code that blocks and return </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@1@netstandard/A.html#045a746eb48cbaa9" class="t t">Task</a>.<a href="@1@netstandard/A.html#66f1c3e3e272f591" class="i property">CompletedTask</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> when</span>
    <span class="c">///</span><span class="c"> finished.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span> <span class="c">snippet</span><span class="c">=</span><span class="c">&quot;</span><span class="c">Snippet:Azure_Core_Samples_EventSamples_SyncHandler</span><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> var client = new AlarmClient();</span>
    <span class="c">///</span><span class="c"> client.Ring += (SyncAsyncEventArgs e) =</span><span class="c">&amp;gt;</span>
    <span class="c">///</span><span class="c"> {</span>
    <span class="c">///</span><span class="c">     Console.WriteLine(</span><span class="c">&amp;quot;</span><span class="c">Wake up!</span><span class="c">&amp;quot;</span><span class="c">);</span>
    <span class="c">///</span><span class="c">     return Task.CompletedTask;</span>
    <span class="c">///</span><span class="c"> };</span>
    <span class="c">///</span>
    <span class="c">///</span><span class="c"> client.Snooze();</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> If you need to call an async method from a synchronous event handler,</span>
    <span class="c">///</span><span class="c"> you have two options.  You can use </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@1@netstandard/A.html#045a746eb48cbaa9" class="t t">Task</a>.<a href="@1@netstandard/A.html#89fc01f3bb88eed9" class="i method">Run</a>(<a href="@1@netstandard/A.html#9147ae6f76643aae" class="t t">Action</a>)<span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> to</span>
    <span class="c">///</span><span class="c"> queue a task for execution on the ThreadPool without waiting on it to</span>
    <span class="c">///</span><span class="c"> complete.  This &quot;fire and forget&quot; approach may not run before your</span>
    <span class="c">///</span><span class="c"> handler finishes executing.  Be sure to understand</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">href</span><span class="c">=</span><span class="c">&quot;</span><span class="c">https://docs.microsoft.com/dotnet/standard/parallel-programming/exception-handling-task-parallel-library</span><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> exception handling in the Task Parallel Library</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span><span class="c"> to avoid</span>
    <span class="c">///</span><span class="c"> unhandled exceptions tearing down your process.  If you absolutely need</span>
    <span class="c">///</span><span class="c"> the async method to execute before returning from your handler, you can</span>
    <span class="c">///</span><span class="c"> call </span><span class="c">&lt;</span><span class="c">c</span><span class="c">&gt;</span><span class="c">myAsyncTask.GetAwaiter().GetResult()</span><span class="c">&lt;/</span><span class="c">c</span><span class="c">&gt;</span><span class="c">.  Please be aware</span>
    <span class="c">///</span><span class="c"> this may cause ThreadPool starvation.  See the sync-over-async note in</span>
    <span class="c">///</span><span class="c"> Remarks for more details.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> If you&#39;re using the asynchronous, non-blocking methods of a client</span>
    <span class="c">///</span><span class="c"> (i.e., methods with an Async suffix), they will raise events that</span>
    <span class="c">///</span><span class="c"> expect handlers to execute asynchronously.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span> <span class="c">snippet</span><span class="c">=</span><span class="c">&quot;</span><span class="c">Snippet:Azure_Core_Samples_EventSamples_AsyncHandler</span><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> var client = new AlarmClient();</span>
    <span class="c">///</span><span class="c"> client.Ring += async (SyncAsyncEventArgs e) =</span><span class="c">&amp;gt;</span>
    <span class="c">///</span><span class="c"> {</span>
    <span class="c">///</span><span class="c">     await Console.Out.WriteLineAsync(</span><span class="c">&amp;quot;</span><span class="c">Wake up!</span><span class="c">&amp;quot;</span><span class="c">);</span>
    <span class="c">///</span><span class="c"> };</span>
    <span class="c">///</span>
    <span class="c">///</span><span class="c"> await client.SnoozeAsync();</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> The same event can be raised from both synchronous and asynchronous</span>
    <span class="c">///</span><span class="c"> code paths depending on whether you&#39;re calling sync or async methods</span>
    <span class="c">///</span><span class="c"> on a client.  If you write an async handler but raise it from a sync</span>
    <span class="c">///</span><span class="c"> method, the handler will be doing sync-over-async and may cause</span>
    <span class="c">///</span><span class="c"> ThreadPool starvation.  See the note in Remarks for more details.  You</span>
    <span class="c">///</span><span class="c"> should use the </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="SyncAsyncEventArgs.cs.html#29b26fe52d12ab1a" class="t t">SyncAsyncEventArgs</a>.<a href="SyncAsyncEventArgs.cs.html#2523057ae25c6a34" class="i property">RunSynchronously</a><span class="c">&quot;</span><span class="c">/&gt;</span>
    <span class="c">///</span><span class="c"> property to check how the event is being raised and implement your</span>
    <span class="c">///</span><span class="c"> handler accordingly.  Here&#39;s an example handler that&#39;s safe to invoke</span>
    <span class="c">///</span><span class="c"> from both sync and async code paths.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span> <span class="c">snippet</span><span class="c">=</span><span class="c">&quot;</span><span class="c">Snippet:Azure_Core_Samples_EventSamples_CombinedHandler</span><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> var client = new AlarmClient();</span>
    <span class="c">///</span><span class="c"> client.Ring += async (SyncAsyncEventArgs e) =</span><span class="c">&amp;gt;</span>
    <span class="c">///</span><span class="c"> {</span>
    <span class="c">///</span><span class="c">     if (e.RunSynchronously)</span>
    <span class="c">///</span><span class="c">     {</span>
    <span class="c">///</span><span class="c">         Console.WriteLine(</span><span class="c">&amp;quot;</span><span class="c">Wake up!</span><span class="c">&amp;quot;</span><span class="c">);</span>
    <span class="c">///</span><span class="c">     }</span>
    <span class="c">///</span><span class="c">     else</span>
    <span class="c">///</span><span class="c">     {</span>
    <span class="c">///</span><span class="c">         await Console.Out.WriteLineAsync(</span><span class="c">&amp;quot;</span><span class="c">Wake up!</span><span class="c">&amp;quot;</span><span class="c">);</span>
    <span class="c">///</span><span class="c">     }</span>
    <span class="c">///</span><span class="c"> };</span>
    <span class="c">///</span>
    <span class="c">///</span><span class="c"> client.Snooze(); // sync call that blocks</span>
    <span class="c">///</span><span class="c"> await client.SnoozeAsync(); // async call that doesn</span><span class="c">&amp;apos;</span><span class="c">t block</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">example</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">example</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">example</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">exception</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@1@netstandard/A.html#be77e0a7fbc110e6" class="t t">AggregateException</a><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> Any exceptions thrown by an event handler will be wrapped in a single</span>
    <span class="c">///</span><span class="c"> AggregateException and thrown from the code that raised the event.  You</span>
    <span class="c">///</span><span class="c"> can check the </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@1@netstandard/A.html#be77e0a7fbc110e6" class="t t">AggregateException</a>.<a href="@1@netstandard/A.html#e9d864767768da2b" class="i property">InnerExceptions</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> property</span>
    <span class="c">///</span><span class="c"> to see the original exceptions thrown by your event handlers.</span>
    <span class="c">///</span><span class="c"> AggregateException also provides</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">href</span><span class="c">=</span><span class="c">&quot;</span><span class="c">https://docs.microsoft.com/en-us/archive/msdn-magazine/2009/brownfield/aggregating-exceptions</span><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> a number of helpful methods</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span><span class="c"> like</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@1@netstandard/A.html#be77e0a7fbc110e6" class="t t">AggregateException</a>.<a href="@1@netstandard/A.html#96eb05ad168f3513" class="i method">Flatten</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> and</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@1@netstandard/A.html#be77e0a7fbc110e6" class="t t">AggregateException</a>.<a href="@1@netstandard/A.html#bca5d3e805d120c0" class="i method">Handle</a>(<a href="@1@netstandard/A.html#7a86aba051da82dd" class="t t">Func</a>{<a href="@1@netstandard/A.html#f092fb2b893a0162" class="t t">Exception</a>, <b>bool</b>})<span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> to make</span>
    <span class="c">///</span><span class="c"> complex failures easier to work with.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">code</span> <span class="c">snippet</span><span class="c">=</span><span class="c">&quot;</span><span class="c">Snippet:Azure_Core_Samples_EventSamples_Exceptions</span><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> var client = new AlarmClient();</span>
    <span class="c">///</span><span class="c"> client.Ring += (SyncAsyncEventArgs e) =</span><span class="c">&amp;gt;</span>
    <span class="c">///</span><span class="c">     throw new InvalidOperationException(</span><span class="c">&amp;quot;</span><span class="c">Alarm unplugged.</span><span class="c">&amp;quot;</span><span class="c">);</span>
    <span class="c">///</span>
    <span class="c">///</span><span class="c"> try</span>
    <span class="c">///</span><span class="c"> {</span>
    <span class="c">///</span><span class="c">     client.Snooze();</span>
    <span class="c">///</span><span class="c"> }</span>
    <span class="c">///</span><span class="c"> catch (AggregateException ex)</span>
    <span class="c">///</span><span class="c"> {</span>
    <span class="c">///</span><span class="c">     ex.Handle(e =</span><span class="c">&amp;gt;</span><span class="c"> e is InvalidOperationException);</span>
    <span class="c">///</span><span class="c">     Console.WriteLine(</span><span class="c">&amp;quot;</span><span class="c">Please switch to your backup alarm.</span><span class="c">&amp;quot;</span><span class="c">);</span>
    <span class="c">///</span><span class="c"> }</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">code</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">exception</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">remarks</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> Most Azure client libraries for .NET offer both synchronous and</span>
    <span class="c">///</span><span class="c"> asynchronous methods for calling Azure services.  You can distinguish</span>
    <span class="c">///</span><span class="c"> the asynchronous methods by their Async suffix.  For example,</span>
    <span class="c">///</span><span class="c"> BlobClient.Download and BlobClient.DownloadAsync make the same</span>
    <span class="c">///</span><span class="c"> underlying REST call and only differ in whether they block.  We</span>
    <span class="c">///</span><span class="c"> recommend using our async methods for new applications, but there are</span>
    <span class="c">///</span><span class="c"> perfectly valid cases for using sync methods as well.  These dual</span>
    <span class="c">///</span><span class="c"> method invocation semantics allow for flexibility, but require a little</span>
    <span class="c">///</span><span class="c"> extra care when writing event handlers.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> The SyncAsyncEventHandler is a delegate used by events in Azure client</span>
    <span class="c">///</span><span class="c"> libraries to represent an event handler that can be invoked from either</span>
    <span class="c">///</span><span class="c"> sync or async code paths.  It takes event arguments deriving from</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="SyncAsyncEventArgs.cs.html#29b26fe52d12ab1a" class="t t">SyncAsyncEventArgs</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> that contain important information for</span>
    <span class="c">///</span><span class="c"> writing your event handler:</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">list</span> <span class="c">type</span><span class="c">=</span><span class="c">&quot;</span><span class="c">bullet</span><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">item</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">description</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="SyncAsyncEventArgs.cs.html#29b26fe52d12ab1a" class="t t">SyncAsyncEventArgs</a>.<a href="SyncAsyncEventArgs.cs.html#0ea70b4f58863568" class="i property">CancellationToken</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> is a cancellation</span>
    <span class="c">///</span><span class="c"> token related to the original operation that raised the event.  It&#39;s</span>
    <span class="c">///</span><span class="c"> important for your handler to pass this token along to any asynchronous</span>
    <span class="c">///</span><span class="c"> or long-running synchronous operations that take a token so cancellation</span>
    <span class="c">///</span><span class="c"> (via something like</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">c</span><span class="c">&gt;</span><span class="c">new CancellationTokenSource(TimeSpan.FromSeconds(10)).Token</span><span class="c">&lt;/</span><span class="c">c</span><span class="c">&gt;</span><span class="c">,</span>
    <span class="c">///</span><span class="c"> for example) will correctly propagate.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">description</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">item</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">item</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">description</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="SyncAsyncEventArgs.cs.html#29b26fe52d12ab1a" class="t t">SyncAsyncEventArgs</a>.<a href="SyncAsyncEventArgs.cs.html#2523057ae25c6a34" class="i property">RunSynchronously</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> is a flag indicating</span>
    <span class="c">///</span><span class="c"> whether your handler was invoked synchronously or asynchronously.  If</span>
    <span class="c">///</span><span class="c"> you&#39;re calling sync methods on your client, you should use sync methods</span>
    <span class="c">///</span><span class="c"> to implement your event handler (you can return</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@1@netstandard/A.html#045a746eb48cbaa9" class="t t">Task</a>.<a href="@1@netstandard/A.html#66f1c3e3e272f591" class="i property">CompletedTask</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c">).  If you&#39;re calling async methods on</span>
    <span class="c">///</span><span class="c"> your client, you should use async methods where possible to implement</span>
    <span class="c">///</span><span class="c"> your event handler.  If you&#39;re not in control of how the client will be</span>
    <span class="c">///</span><span class="c"> used or want to write safer code, you should check the</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="SyncAsyncEventArgs.cs.html#29b26fe52d12ab1a" class="t t">SyncAsyncEventArgs</a>.<a href="SyncAsyncEventArgs.cs.html#2523057ae25c6a34" class="i property">RunSynchronously</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> property and call</span>
    <span class="c">///</span><span class="c"> either sync or async methods as directed.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">description</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">item</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">item</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">description</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> Most events will customize the event data by deriving from</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="SyncAsyncEventArgs.cs.html#29b26fe52d12ab1a" class="t t">SyncAsyncEventArgs</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> and including details about what</span>
    <span class="c">///</span><span class="c"> triggered the event or providing options to react.  Many times this</span>
    <span class="c">///</span><span class="c"> will include a reference to the client that raised the event in case</span>
    <span class="c">///</span><span class="c"> you need it for additional processing.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">description</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">item</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">list</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> When an event using SyncAsyncEventHandler is raised, the handlers will</span>
    <span class="c">///</span><span class="c"> be executed sequentially to avoid introducing any unintended</span>
    <span class="c">///</span><span class="c"> parallelism.  The event handlers will finish before returning control</span>
    <span class="c">///</span><span class="c"> to the code path raising the event.  This means blocking for events</span>
    <span class="c">///</span><span class="c"> raised synchronously and waiting for the returned </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@1@netstandard/A.html#045a746eb48cbaa9" class="t t">Task</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> to</span>
    <span class="c">///</span><span class="c"> complete for events raised asynchronously.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> Any exceptions thrown from a handler will be wrapped in a single</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="@1@netstandard/A.html#be77e0a7fbc110e6" class="t t">AggregateException</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c">.  If one handler throws an exception,</span>
    <span class="c">///</span><span class="c"> it will not prevent other handlers from running.  This is also relevant</span>
    <span class="c">///</span><span class="c"> for cancellation because all handlers are still raised if cancellation</span>
    <span class="c">///</span><span class="c"> occurs.  You should both pass </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="SyncAsyncEventArgs.cs.html#29b26fe52d12ab1a" class="t t">SyncAsyncEventArgs</a>.<a href="SyncAsyncEventArgs.cs.html#0ea70b4f58863568" class="i property">CancellationToken</a><span class="c">&quot;</span><span class="c">/&gt;</span>
    <span class="c">///</span><span class="c"> to asynchronous or long-running synchronous operations and consider</span>
    <span class="c">///</span><span class="c"> calling </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><span class="i n">System</span>.<span class="i n">Threading</span>.<a href="@1@netstandard/A.html#36b17ded8b1a228c" class="t t">CancellationToken</a>.<a href="@1@netstandard/A.html#d2864d73804288fc" class="i method">ThrowIfCancellationRequested</a><span class="c">&quot;</span><span class="c">/&gt;</span>
    <span class="c">///</span><span class="c"> in compute heavy handlers.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> A </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">href</span><span class="c">=</span><span class="c">&quot;</span><span class="c">https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/core/Azure.Core/samples/Diagnostics.md#distributed-tracing</span><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> distributed tracing span</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span><span class="c"> is wrapped around your handlers using</span>
    <span class="c">///</span><span class="c"> the event name so you can see how long your handlers took to run,</span>
    <span class="c">///</span><span class="c"> whether they made other calls to Azure services, and details about any</span>
    <span class="c">///</span><span class="c"> exceptions that were thrown.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> Executing asynchronous code from a sync code path is commonly referred</span>
    <span class="c">///</span><span class="c"> to as sync-over-async because you&#39;re getting sync behavior but still</span>
    <span class="c">///</span><span class="c"> invoking all the async machinery. See</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">href</span><span class="c">=</span><span class="c">&quot;</span><span class="c">https://docs.microsoft.com/archive/blogs/vancem/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall</span><span class="c">&quot;</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> Diagnosing.NET Core ThreadPool Starvation with PerfView</span><span class="c">&lt;/</span><span class="c">see</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> for a detailed explanation of how that can cause serious performance</span>
    <span class="c">///</span><span class="c"> problems.  We recommend you use the</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">see</span> <span class="c">cref</span><span class="c">=</span><span class="c">&quot;</span><a href="SyncAsyncEventArgs.cs.html#29b26fe52d12ab1a" class="t t">SyncAsyncEventArgs</a>.<a href="SyncAsyncEventArgs.cs.html#2523057ae25c6a34" class="i property">RunSynchronously</a><span class="c">&quot;</span><span class="c">/&gt;</span><span class="c"> flag to avoid</span>
    <span class="c">///</span><span class="c"> ThreadPool starvation.</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">para</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">remarks</span><span class="c">&gt;</span>
    <b>public delegate</b> <a href="@1@netstandard/A.html#045a746eb48cbaa9" class="t t">Task</a> <a id="f3bd5b5640cd10dd" href="R/f3bd5b5640cd10dd.html" target="n" data-glyph="12,0" class="t t"><span id="23a94725801e792a">SyncAsyncEventHandler</span></a>&lt;<span id="r0 rd t" class="r0 r t">T</span>&gt;(<span class="r0 r t">T</span> <span id="r1 rd" class="r1 r">e</span>)
        <b>where</b> <span class="r0 r t">T</span> : <a href="SyncAsyncEventArgs.cs.html#29b26fe52d12ab1a" class="t t">SyncAsyncEventArgs</a>;
 
    <span class="c">// NOTE: You should always use SyncAsyncEventHandlerExtensions.RaiseAsync</span>
    <span class="c">// in Azure.Core&#39;s shared source to ensure consistent event handling</span>
    <span class="c">// semantics.</span>
}
</pre></td></tr></table></div></body></html>
