<!DOCTYPE html>
<html><head><title>HttpWebRequestTransport.cs</title><link rel="stylesheet" href="../../styles.css"><script src="../../scripts.js"></script></head>
<body class="cB" onload="i(379);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#Azure.Core/Pipeline/HttpWebRequestTransport.cs" target="_top">Pipeline\HttpWebRequestTransport.cs</a><br/></td><td></td></tr>
<tr><td>Project: <a id="projectPath" class="blueLink" href="/#Azure.Core" target="_top">Azure.Core.csproj</a> (Azure.Core)</td><td></td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
<span class="c">// Copyright (c) Microsoft Corporation. All rights reserved.</span>
<span class="c">// Licensed under the MIT License.</span>
 
<b>using</b> <span class="i n">System</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Collections</span>.<span class="i n">Generic</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Diagnostics</span>.<span class="i n">CodeAnalysis</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Globalization</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">IO</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Linq</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Net</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Net</span>.<span class="i n">Http</span>.<span class="i n">Headers</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Threading</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Threading</span>.<span class="i n">Tasks</span>;
 
<b>namespace</b> <span class="i n">Azure</span>.<span class="i n">Core</span>.<span class="i n">Pipeline</span>
{
<span class="k preprocess">#</span><span class="k preprocess">if</span> <span class="i">NETFRAMEWORK</span>
<span class="e">    /// &lt;summary&gt;
    /// The &lt;see cref=&quot;HttpWebRequest&quot;/&gt; based &lt;see cref=&quot;HttpPipelineTransport&quot;/&gt; implementation.
    /// &lt;/summary&gt;
    internal class HttpWebRequestTransport : HttpPipelineTransport
    {
        private readonly Action&lt;HttpWebRequest&gt; _configureRequest;
        public static readonly HttpWebRequestTransport Shared = new HttpWebRequestTransport();
        private readonly IWebProxy? _environmentProxy;
 
        /// &lt;summary&gt;
        /// Creates a new instance of &lt;see cref=&quot;HttpWebRequestTransport&quot;/&gt;
        /// &lt;/summary&gt;
        public HttpWebRequestTransport(): this (_ =&gt; { })
        {
        }
 
        internal HttpWebRequestTransport(Action&lt;HttpWebRequest&gt; configureRequest)
        {
            _configureRequest = configureRequest;
            if (HttpEnvironmentProxy.TryCreate(out IWebProxy webProxy))
            {
                _environmentProxy = webProxy;
            }
        }
 
        /// &lt;inheritdoc /&gt;
        public override void Process(HttpMessage message)
        {
            ProcessInternal(message, false).EnsureCompleted();
        }
 
        /// &lt;inheritdoc /&gt;
        public override async ValueTask ProcessAsync(HttpMessage message)
        {
            await ProcessInternal(message, true).ConfigureAwait(false);
        }
 
        private async ValueTask ProcessInternal(HttpMessage message, bool async)
        {
            var request = CreateRequest(message.Request);
 
            ServicePointHelpers.SetLimits(request.ServicePoint);
 
            using var registration = message.CancellationToken.Register(state =&gt; ((HttpWebRequest) state).Abort(), request);
            try
            {
                if (message.Request.Content != null)
                {
                    using var requestStream = async ? await request.GetRequestStreamAsync().ConfigureAwait(false) : request.GetRequestStream();
 
                    if (async)
                    {
                        await message.Request.Content.WriteToAsync(requestStream, message.CancellationToken).ConfigureAwait(false);
                    }
                    else
                    {
                        message.Request.Content.WriteTo(requestStream, message.CancellationToken);
                    }
                }
                else
                {
                    request.ContentLength = 0;
                }
 
                WebResponse webResponse;
                try
                {
                    webResponse = async ? await request.GetResponseAsync().ConfigureAwait(false) : request.GetResponse();
                }
                // HttpWebRequest throws for error responses catch that
                catch (WebException exception) when (exception.Response != null)
                {
                    webResponse = exception.Response;
                }
 
                message.Response = new HttpWebResponseImplementation(message.Request.ClientRequestId, (HttpWebResponse) webResponse);
            }
            // ObjectDisposedException might be thrown if the request is aborted during the content upload via SSL
            catch (ObjectDisposedException) when (message.CancellationToken.IsCancellationRequested)
            {
                throw new TaskCanceledException();
            }
            // WebException is thrown in the case of .Abort() call
            catch (WebException) when (message.CancellationToken.IsCancellationRequested)
            {
                throw new TaskCanceledException();
            }
            catch (WebException webException)
            {
                throw new RequestFailedException(0, webException.Message);
            }
        }
 
        private HttpWebRequest CreateRequest(Request messageRequest)
        {
            var request = WebRequest.CreateHttp(messageRequest.Uri.ToUri());
 
            // Timeouts are handled by the pipeline
            request.Timeout = Timeout.Infinite;
            request.ReadWriteTimeout = Timeout.Infinite;
 
            // Don&#39;t disable the default proxy when there is no environment proxy configured
            if (_environmentProxy != null)
            {
                request.Proxy = _environmentProxy;
            }
 
            _configureRequest(request);
 
            request.Method = messageRequest.Method.Method;
            foreach (var messageRequestHeader in messageRequest.Headers)
            {
                if (string.Equals(messageRequestHeader.Name, HttpHeader.Names.ContentLength, StringComparison.OrdinalIgnoreCase))
                {
                    request.ContentLength = long.Parse(messageRequestHeader.Value, CultureInfo.InvariantCulture);
                    continue;
                }
 
                if (string.Equals(messageRequestHeader.Name, HttpHeader.Names.Host, StringComparison.OrdinalIgnoreCase))
                {
                    request.Host = messageRequestHeader.Value;
                    continue;
                }
 
                if (string.Equals(messageRequestHeader.Name, HttpHeader.Names.Date, StringComparison.OrdinalIgnoreCase))
                {
                    request.Date = DateTime.Parse(messageRequestHeader.Value, CultureInfo.InvariantCulture);
                    continue;
                }
 
                if (string.Equals(messageRequestHeader.Name, HttpHeader.Names.ContentType, StringComparison.OrdinalIgnoreCase))
                {
                    request.ContentType = messageRequestHeader.Value;
                    continue;
                }
 
                if (string.Equals(messageRequestHeader.Name, HttpHeader.Names.UserAgent, StringComparison.OrdinalIgnoreCase))
                {
                    request.UserAgent = messageRequestHeader.Value;
                    continue;
                }
 
                if (string.Equals(messageRequestHeader.Name, HttpHeader.Names.Accept, StringComparison.OrdinalIgnoreCase))
                {
                    request.Accept = messageRequestHeader.Value;
                    continue;
                }
 
                if (string.Equals(messageRequestHeader.Name, HttpHeader.Names.Referer, StringComparison.OrdinalIgnoreCase))
                {
                    request.Referer = messageRequestHeader.Value;
                    continue;
                }
 
                if (string.Equals(messageRequestHeader.Name, HttpHeader.Names.IfModifiedSince, StringComparison.OrdinalIgnoreCase))
                {
                    request.IfModifiedSince = DateTime.Parse(messageRequestHeader.Value, CultureInfo.InvariantCulture);
                    continue;
                }
 
                if (string.Equals(messageRequestHeader.Name, &quot;Expect&quot;, StringComparison.OrdinalIgnoreCase))
                {
                    request.Expect = messageRequestHeader.Value;
                    continue;
                }
 
                if (string.Equals(messageRequestHeader.Name, &quot;Transfer-Encoding&quot;, StringComparison.OrdinalIgnoreCase))
                {
                    request.TransferEncoding = messageRequestHeader.Value;
                    continue;
                }
 
                if (string.Equals(messageRequestHeader.Name, HttpHeader.Names.Range, StringComparison.OrdinalIgnoreCase))
                {
                    var value = RangeHeaderValue.Parse(messageRequestHeader.Value);
                    if (value.Unit != &quot;bytes&quot;)
                    {
                        throw new InvalidOperationException(&quot;Only ranges with bytes unit supported.&quot;);
                    }
 
                    foreach (var rangeItem in value.Ranges)
                    {
                        if (rangeItem.From == null)
                        {
                            throw new InvalidOperationException(&quot;Only ranges with Offset supported.&quot;);
                        }
 
                        if (rangeItem.To == null)
                        {
                            request.AddRange(rangeItem.From.Value);
                        }
                        else
                        {
                            request.AddRange(rangeItem.From.Value, rangeItem.To.Value);
                        }
                    }
                    continue;
                }
 
                request.Headers.Add(messageRequestHeader.Name, messageRequestHeader.Value);
            }
 
            if (request.ContentLength == -1 &amp;&amp;
                messageRequest.Content != null &amp;&amp;
                messageRequest.Content.TryComputeLength(out var length))
            {
                request.ContentLength = length;
            }
 
            if (request.ContentLength != -1)
            {
                // disable buffering when the content length is known
                // as the content stream is re-playable and we don&#39;t want to allocate extra buffers
                request.AllowWriteStreamBuffering = false;
            }
            return request;
        }
 
        /// &lt;inheritdoc /&gt;
        public override Request CreateRequest()
        {
            return new HttpWebRequestImplementation();
        }
 
        private sealed class HttpWebResponseImplementation: Response
        {
            private readonly HttpWebResponse _webResponse;
            private Stream? _contentStream;
            private Stream? _originalContentStream;
 
            public HttpWebResponseImplementation(string clientRequestId, HttpWebResponse webResponse)
            {
                _webResponse = webResponse;
                _originalContentStream = _webResponse.GetResponseStream();
                _contentStream = _originalContentStream;
                ClientRequestId = clientRequestId;
            }
 
            public override int Status =&gt; (int) _webResponse.StatusCode;
 
            public override string ReasonPhrase =&gt; _webResponse.StatusDescription;
 
            public override Stream? ContentStream
            {
                get =&gt; _contentStream;
                set
                {
                    // Make sure we don&#39;t dispose the content if the stream was replaced
                    _originalContentStream = null;
 
                    _contentStream = value;
                }
            }
 
            public override string ClientRequestId { get; set; }
 
            public override void Dispose()
            {
                _originalContentStream?.Dispose();
            }
 
            protected internal override bool TryGetHeader(string name, [NotNullWhen(true)] out string? value)
            {
                value = _webResponse.Headers.Get(name);
                return value != null;
            }
 
            protected internal override bool TryGetHeaderValues(string name, [NotNullWhen(true)] out IEnumerable&lt;string&gt;? values)
            {
                values = _webResponse.Headers.GetValues(name);
                return values != null;
            }
 
            protected internal override bool ContainsHeader(string name)
            {
                return _webResponse.Headers.Get(name) != null;
            }
 
            protected internal override IEnumerable&lt;HttpHeader&gt; EnumerateHeaders()
            {
                foreach (var key in _webResponse.Headers.AllKeys)
                {
                    yield return new HttpHeader(key, _webResponse.Headers.Get(key));
                }
            }
        }
 
        private sealed class HttpWebRequestImplementation: Request
        {
            public HttpWebRequestImplementation()
            {
                Method = RequestMethod.Get;
            }
 
            private string? _clientRequestId;
            private readonly Dictionary&lt;string, List&lt;string&gt;&gt; _headers = new Dictionary&lt;string, List&lt;string&gt;&gt;(StringComparer.OrdinalIgnoreCase);
 
            protected internal override void AddHeader(string name, string value)
            {
                if (!_headers.TryGetValue(name, out List&lt;string&gt; values))
                {
                    _headers[name] = values = new List&lt;string&gt;();
                }
 
                values.Add(value);
            }
 
            protected internal override bool TryGetHeader(string name, [NotNullWhen(true)] out string? value)
            {
                if (_headers.TryGetValue(name, out List&lt;string&gt; values))
                {
                    value = JoinHeaderValue(values);
                    return true;
                }
 
                value = null;
                return false;
            }
 
            protected internal override bool TryGetHeaderValues(string name, out IEnumerable&lt;string&gt; values)
            {
                var result = _headers.TryGetValue(name, out List&lt;string&gt; valuesList);
                values = valuesList;
                return result;
            }
 
            protected internal override bool ContainsHeader(string name)
            {
                return TryGetHeaderValues(name, out _);
            }
 
            protected internal override bool RemoveHeader(string name)
            {
                return _headers.Remove(name);
            }
 
            protected internal override IEnumerable&lt;HttpHeader&gt; EnumerateHeaders() =&gt; _headers.Select(h =&gt; new HttpHeader(h.Key, JoinHeaderValue(h.Value)));
 
            private static string JoinHeaderValue(IEnumerable&lt;string&gt; values)
            {
                return string.Join(&quot;,&quot;, values);
            }
            public override string ClientRequestId
            {
                get =&gt; _clientRequestId ??= Guid.NewGuid().ToString();
                set
                {
                    Argument.AssertNotNull(value, nameof(value));
                    _clientRequestId = value;
                }
            }
 
            public override RequestContent? Content { get; set; }
 
            public override void Dispose()
            {
                Content?.Dispose();
            }
        }
    }
</span><span class="k preprocess">#</span><span class="k preprocess">endif</span>
}</pre></td></tr></table></div></body></html>
