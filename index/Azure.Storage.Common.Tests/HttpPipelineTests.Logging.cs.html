<!DOCTYPE html>
<html><head><title>HttpPipelineTests.Logging.cs</title><link rel="stylesheet" href="../styles.css"><script src="../scripts.js"></script></head>
<body class="cB" onload="i(171);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#Azure.Storage.Common.Tests/HttpPipelineTests.Logging.cs" target="_top">HttpPipelineTests.Logging.cs</a><br/></td><td></td></tr>
<tr><td>Project: <a id="projectPath" class="blueLink" href="/#Azure.Storage.Common.Tests" target="_top">Azure.Storage.Common.Tests.csproj</a> (Azure.Storage.Common.Tests)</td><td></td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
<span class="c">// Copyright (c) Microsoft Corporation. All rights reserved.</span>
<span class="c">// Licensed under the MIT License.</span>
 
<b>namespace</b> <span class="i n">Azure</span>.<span class="i n">Storage</span>.<span class="i n">Test</span>
{
    <b>internal</b> <b>partial</b> <b>class</b> <a id="3488b6fc4c889426" href="R/../../0000000000.html" target="n" data-glyph="2,0" class="t t"><span id="a40d520a338863ec">HttpPipelineTests</span></a>
    {
        <span class="c">/*
        [Test]
        [NonParallelizable]
        public async Task Logging_Shared_Key_Redact()
        {
            var sourceSwitch = new SourceSwitch(&quot;sourceSwitch&quot;) { Level = SourceLevels.All };
 
            using (var textWriter = new StringWriter())
            using (var textWriterListener = new TextWriterTraceListener(textWriter))
            {
                var httpRequest = new HttpRequestMessage();
                httpRequest.Headers.Authorization = AuthenticationHeaderValue.Parse(&quot;auth&quot;);
                var serviceCollection =
                    new ServiceCollection()
                    .AddLogging(
                        builder =&gt;
                        builder
                        .AddTraceSource(sourceSwitch, textWriterListener)
                        .AddFilter(level =&gt; true) // do not filter by level
                        );
 
                await Logging_TextWriterTestImpl(textWriter, serviceCollection, httpRequest, () =&gt;
                {
                    Assert.IsFalse(textWriter.ToString().Contains(&quot;auth&quot;));
                });
            }
        }
 
        [Test]
        [NonParallelizable]
        public async Task Logging_SAS_Redact()
        {
            var sourceSwitch = new SourceSwitch(&quot;sourceSwitch&quot;) { Level = SourceLevels.All };
 
            using (var textWriter = new StringWriter())
            using (var textWriterListener = new TextWriterTraceListener(textWriter))
            {
                var httpRequest = new HttpRequestMessage
                {
                    RequestUri = new Uri(&quot;http://dev.blob.core.windows.net/test-container/test-blob?sv=2018-03-29&amp;ss=f&amp;srt=s&amp;st=2018-10-30T20%3A45%3A11Z&amp;se=2019-10-29T22%3A45%3A11Z&amp;sp=rw&amp;sig=urlSignature&amp;comp=incrementalcopy&quot;)
                };
                httpRequest.Headers.Add(Constants.CopySource, &quot;http://dev.blob.core.windows.net/test-container/test-blob?snapshot=2018-10-30T19:19:22.1016437Z&amp;sv=2018-03-28&amp;ss=b&amp;srt=co&amp;st=2018-10-29T20:45:11Z&amp;se=2018-10-29T22:45:11Z&amp;sp=rwdlac&amp;sig=copySourceSignature&quot;);
                var serviceCollection =
                    new ServiceCollection()
                    .AddLogging(
                        builder =&gt;
                        builder
                        .AddTraceSource(sourceSwitch, textWriterListener)
                        .AddFilter(level =&gt; true) // do not filter by level
                        );
 
                await Logging_TextWriterTestImpl(textWriter, serviceCollection, httpRequest, () =&gt;
                {
                    Assert.IsFalse(textWriter.ToString().Contains(&quot;urlSignature&quot;));
                    Assert.IsFalse(textWriter.ToString().Contains(&quot;copySourceSignature&quot;));
                });
            }
        }
 
        [Test]
        [Ignore(&quot;Needs permissions&quot;)]
        [NonParallelizable]
        public async Task Logging_EventLog()
        {
            var serviceCollection =
                new ServiceCollection()
                .AddLogging(
                    builder =&gt;
                    builder
                    .AddEventLog(new EventLogSettings { LogName = &quot;Test&quot;, SourceName = typeof(HttpPipelineTests).FullName + &quot;#&quot; + nameof(EventLog) })
                    .AddFilter(level =&gt; true) // do not filter by level
                    );
 
            await Logging_TestImpl(serviceCollection);
        }
 
        [Test]
        [NonParallelizable]
        public async Task Logging_ConsoleLog()
        {
            using (var textWriter = new StringWriter())
            {
                Console.SetOut(textWriter);
 
                var serviceCollection =
                    new ServiceCollection()
                    .AddLogging(
                        builder =&gt;
                        builder
                        .AddConsole(options =&gt; options.IncludeScopes = true)
                        .AddFilter(level =&gt; true) // do not filter by level
                        );
 
                await Logging_TextWriterTestImpl(textWriter, serviceCollection);
            }
        }
 
        [Test]
        [NonParallelizable]
        public async Task Logging_TraceLog()
        {
            var sourceSwitch = new SourceSwitch(&quot;sourceSwitch&quot;) { Level = SourceLevels.All };
 
            using (var textWriter = new StringWriter())
            using (var textWriterListener = new TextWriterTraceListener(textWriter))
            using (var consoleListener = new TextWriterTraceListener(Console.Out))
            {
                var serviceCollection =
                    new ServiceCollection()
                    .AddLogging(
                        builder =&gt;
                        builder
                        .AddTraceSource(sourceSwitch, textWriterListener)
                        .AddTraceSource(sourceSwitch, consoleListener)
                        .AddFilter(level =&gt; true) // do not filter by level
                        );
 
                await Logging_TextWriterTestImpl(textWriter, serviceCollection);
            }
        }
 
        static async Task Logging_TextWriterTestImpl(StringWriter textWriter, IServiceCollection serviceCollection, HttpRequestMessage httpRequest = null, Action action = null)
        {
            Assert.IsTrue(String.IsNullOrWhiteSpace(textWriter.ToString()));
 
            await Logging_TestImpl(serviceCollection, httpRequest);
 
            Assert.IsFalse(String.IsNullOrWhiteSpace(textWriter.ToString()), $&quot;{nameof(textWriter)} did not receive any Log messages&quot;);
            action?.Invoke();
        }
 
        static async Task Logging_TestImpl(IServiceCollection serviceCollection, HttpRequestMessage httpRequest = null)
        {
            using (var loggerFactory = serviceCollection.BuildServiceProvider().GetService&lt;ILoggerFactory&gt;())
            {
                var logger = loggerFactory.CreateLogger(&quot;logger&quot;);
 
                foreach (var level in new[] { LogLevel.Critical, LogLevel.Debug, LogLevel.Error, LogLevel.Information, LogLevel.Trace, LogLevel.Warning })
                {
                    if (!logger.IsEnabled(level))
                    {
                        Assert.Inconclusive($&quot;{nameof(logger)} not enabled for LogLevel {level}&quot;);
                    }
                }
 
                var pipeline = new Pipeline(
                    new PipelineOptions { Logger = logger },
                    new IPipelinePolicyFactory[] { }
                    );
 
                try
                {
                    await pipeline.SendAsync(httpRequest ?? new HttpRequestMessage(), cancellationToken: CancellationToken.None, default);
                }
                catch (InvalidOperationException e) when (e.Message.StartsWith(&quot;An invalid request URI was provided.&quot;))
                {
                    // expected: we passed a bad request
                }
            }
        }
        */</span>
    }
}
</pre></td></tr></table></div></body></html>
